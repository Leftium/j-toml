/*!@preserve@license
 * 模块名称：j-toml
 * 模块功能：龙腾道为汤小明语写的实现。从属于“简计划”。
   　　　　　An implementation of TOML written by LongTengDao. Belong to "Plan J".
 * 模块版本：1.37.0
 * 许可条款：LGPL-3.0
 * 所属作者：龙腾道 <LongTengDao@LongTengDao.com> (www.LongTengDao.com)
 * 问题反馈：https://GitHub.com/LongTengDao/j-toml/issues
 * 项目主页：https://GitHub.com/LongTengDao/j-toml/
 */
const version="1.37.0",SyntaxError$1=SyntaxError,RangeError$1=RangeError,TypeError$1=TypeError,Error$1={if:Error}.if,undefined$1=void 0,BigInt$1="undefined"==typeof BigInt?undefined$1:BigInt,RegExp$1=RegExp,WeakMap$1=WeakMap,get=WeakMap.prototype.get,set=WeakMap.prototype.set,create$1=Object.create,isSafeInteger=Number.isSafeInteger,getOwnPropertyNames=Object.getOwnPropertyNames,freeze=Object.freeze,isPrototypeOf=Object.prototype.isPrototypeOf,NULL=Object.seal?Object.preventExtensions(Object.create(null)):null,bind=Function.prototype.bind,test=RegExp.prototype.test,exec=RegExp.prototype.exec,apply$1=Reflect.apply,Proxy$1=Proxy,toStringTag="undefined"==typeof Symbol?undefined$1:Symbol.toStringTag,Object_defineProperty=Object.defineProperty,assign$1=Object.assign,Object$1=Object,floor=Math.floor,isArray$1=Array.isArray,Infinity=1/0,fromCharCode=String.fromCharCode,Array$1=Array,hasOwnProperty=Object.prototype.hasOwnProperty,propertyIsEnumerable=Object.prototype.propertyIsEnumerable,apply=Function.prototype.apply;var isEnum=propertyIsEnumerable.call.bind(propertyIsEnumerable),hasOwn=Object$1.hasOwn||function(){return hasOwnProperty.bind?hasOwnProperty.call.bind(hasOwnProperty):function(e,t){return hasOwnProperty.call(e,t)}}(),create=Object$1.create;function Descriptor(e){var t=create(NULL);return hasOwn(e,"value")&&(t.value=e.value),hasOwn(e,"writable")&&(t.writable=e.writable),hasOwn(e,"get")&&(t.get=e.get),hasOwn(e,"set")&&(t.set=e.set),hasOwn(e,"enumerable")&&(t.enumerable=e.enumerable),hasOwn(e,"configurable")&&(t.configurable=e.configurable),t}const Default=function(e,t){if(t||"function"==typeof e||(t=e,e=create$1(NULL)),assign$1)assign$1(e,t);else for(var r in t)hasOwn(t,r)&&(e[r]=t[r]);if(e.default=e,"function"==typeof e)e.prototype&&freeze(e.prototype);else if(toStringTag){var n=create$1(NULL);n.value="Module",Object_defineProperty(e,toStringTag,n)}return freeze(e)};var Test=bind?bind.bind(test):function(e){return function(t){return test.call(e,t)}},Exec=bind?bind.bind(exec):function(e){return function(t){return exec.call(e,t)}};function __PURE__(e){var t=e.test=Test(e),r=e.exec=Exec(e),n=t.source=r.source=e.source;return t.unicode=r.unicode=e.unicode,t.ignoreCase=r.ignoreCase=e.ignoreCase,t.multiline=r.multiline=n.indexOf("^")<0&&n.indexOf("$")<0?null:e.multiline,t.dotAll=r.dotAll=n.indexOf(".")<0?null:e.dotAll,e}function theRegExp(e){return __PURE__(e)}var NT=/[\n\t]+/g,ESCAPE=/\\./g;function graveAccentReplacer(e){return"\\`"===e?"`":e}var includes="".includes?function(e,t){return e.includes(t)}:function(e,t){return e.indexOf(t)>-1};function RE(e){for(var t=this.U,r=this.I,n=this.M,i=this.S,a=e.raw,s=a[0].replace(NT,""),l=1,o=arguments.length;l!==o;){var c=arguments[l];if("string"==typeof c)s+=c;else{var u=c.source;if("string"!=typeof u)throw TypeError$1("source");if(c.unicode===t)throw SyntaxError$1("unicode");if(c.ignoreCase===r)throw SyntaxError$1("ignoreCase");if(c.multiline===n&&(includes(u,"^")||includes(u,"$")))throw SyntaxError$1("multiline");if(c.dotAll===i&&includes(u,"."))throw SyntaxError$1("dotAll");s+=u}s+=a[l++].replace(NT,"")}var _=RegExp$1(t?s=s.replace(ESCAPE,graveAccentReplacer):s,this.flags),E=_.test=Test(_),h=_.exec=Exec(_);return E.source=h.source=s,E.unicode=h.unicode=!t,E.ignoreCase=h.ignoreCase=!r,E.multiline=h.multiline=includes(s,"^")||includes(s,"$")?!n:null,E.dotAll=h.dotAll=includes(s,".")?!i:null,_}var RE_bind=bind&&bind.bind(RE);function Context(e){return{U:!includes(e,"u"),I:!includes(e,"i"),M:!includes(e,"m"),S:!includes(e,"s"),flags:e}}var CONTEXT=Context(""),newRegExp=Proxy$1?new Proxy$1(RE,{apply:function(e,t,r){return apply$1(e,CONTEXT,r)},get:function(e,t){return RE_bind(Context(t))},defineProperty:function(){return!1},preventExtensions:function(){return!1}}):function(){RE.apply=RE.apply;for(var e=function(){return RE.apply(CONTEXT,arguments)},t=63;t--;)!function(t){e[t.flags]=function(){return RE.apply(t,arguments)}}(Context((1&t?"":"d")+(2&t?"":"g")+(4&t?"":"i")+(8&t?"":"m")+(8&t?"":"s")+(16&t?"":"u")+(32&t?"":"y")));return freeze?freeze(e):e}(),clearRegExp="$_"in RegExp$1?function(){var e=/^/;return e.test=e.test,function(t){return e.test(""),t}}():function(e){return e},clearRegExp$1=clearRegExp,NEED_TO_ESCAPE_IN_REGEXP=/^[$()*+\-.?[\\\]^{|]/,SURROGATE_PAIR=/^[\uD800-\uDBFF][\uDC00-\uDFFF]/,GROUP=create$1(NULL);function groupify(e,t,r){for(var n=create$1(NULL),i=t?appendPointBranch:appendCodeBranch,a=e.length,s=0;s<a;++s)i(n,e[s]);return sourcify(n,!r)}function appendPointBranch(e,t){if(t){var r=SURROGATE_PAIR.test(t)?t.slice(0,2):t.charAt(0);appendPointBranch(e[r]||(e[r]=create$1(NULL)),t.slice(r.length))}else e[""]=GROUP}function appendCodeBranch(e,t){if(t){var r=t.charAt(0);appendCodeBranch(e[r]||(e[r]=create$1(NULL)),t.slice(1))}else e[""]=GROUP}function sourcify(e,t){var r=[],n=[],i=!0;for(var a in e)if(a){var s=sourcify(e[a],t);t&&NEED_TO_ESCAPE_IN_REGEXP.test(a)&&(a="\\"+a),s?r.push(a+s):n.push(a)}else i=!1;return n.length&&r.unshift(1===n.length?n[0]:"["+n.join("")+"]"),0===r.length?"":(1===r.length&&(n.length||i)?r[0]:"(?:"+r.join("|")+")")+(i?"":"?")}const WeakSet$1=WeakSet,has=WeakSet.prototype.has,add=WeakSet.prototype.add,del=WeakSet.prototype.delete,keys=Object.keys,getOwnPropertySymbols=Object.getOwnPropertySymbols,Null$1=function(){var e=Object.assign||function(e,t){var r,n,i;for(r=keys(t),n=0;n<r.length;++n)e[i=r[n]]=t[i];if(getOwnPropertySymbols)for(r=getOwnPropertySymbols(t),n=0;n<r.length;++n)isEnum(t,i=r[n])&&(e[i]=t[i]);return e};function t(e){return delete e.prototype.constructor,freeze(e.prototype),e}function r(r){return r===undefined$1?this:"function"==typeof r?t(r):e(create(NULL),r)}return delete r.name,r.prototype=null,freeze(r),r}(),is=Object.is,Object_defineProperties=Object.defineProperties,fromEntries=Object.fromEntries,Reflect_construct=Reflect.construct,Reflect_defineProperty=Reflect.defineProperty,Reflect_deleteProperty=Reflect.deleteProperty,ownKeys=Reflect.ownKeys,Keeper=()=>[],newWeakMap=()=>{const e=new WeakMap$1;return e.has=e.has,e.get=e.get,e.set=e.set,e},target2keeper=newWeakMap(),proxy2target=newWeakMap(),target2proxy=newWeakMap(),handlers=assign$1(create$1(NULL),{defineProperty:(e,t,r)=>{if(hasOwn(e,t))return Reflect_defineProperty(e,t,assign$1(create$1(NULL),r));if(Reflect_defineProperty(e,t,assign$1(create$1(NULL),r))){const r=target2keeper.get(e);return r[r.length]=t,!0}return!1},deleteProperty:(e,t)=>{if(Reflect_deleteProperty(e,t)){const r=target2keeper.get(e),n=r.indexOf(t);return n<0||--r.copyWithin(n,n+1).length,!0}return!1},ownKeys:e=>target2keeper.get(e),construct:(e,t,r)=>orderify(Reflect_construct(e,t,r)),apply:(e,t,r)=>orderify(apply$1(e,t,r))}),newProxy=(e,t)=>{target2keeper.set(e,t);const r=new Proxy$1(e,handlers);return proxy2target.set(r,e),r},orderify=e=>{if(proxy2target.has(e))return e;let t=target2proxy.get(e);return t||(t=newProxy(e,assign$1([],ownKeys(e))),target2proxy.set(e,t),t)},Null=function(){function e(){throw TypeError$1("Super constructor Null cannot be invoked with 'new'")}function t(){throw TypeError$1("Super constructor Null cannot be invoked without 'new'")}const r=e=>(delete e.prototype.constructor,freeze(e.prototype),e);function n(i){return new.target?new.target===n?e():newProxy(this,[]):"function"==typeof i?r(i):t()}return n.prototype=null,Object_defineProperty(n,"name",assign$1(create$1(NULL),{value:"",configurable:!1})),freeze(n),n}(),map_has=WeakMap.prototype.has,map_del=WeakMap.prototype.delete,INLINES=new WeakMap$1,SECTIONS=new WeakSet$1,deInline=map_del.bind(INLINES),deSection=del.bind(SECTIONS),isInline=map_has.bind(INLINES),ofInline=get.bind(INLINES),beInline=set.bind(INLINES),inline=(e,t,r)=>{if(isArray$1(e)){if(r)t=3;else if(t===undefined$1)t=3;else if(0!==t&&1!==t&&2!==t&&3!==t)throw"number"==typeof t?RangeError$1(`array inline mode must be 0 | 1 | 2 | 3, not including ${t}`):TypeError$1('array inline mode must be "number" type, not including '+(null===t?'"null"':typeof t));beInline(e,t)}else beInline(e,!0),deSection(e);return e},multilineTable=e=>(beInline(e,!1),deSection(e),e),multilineArray=e=>(deInline(e),e),isSection=has.bind(SECTIONS),beSection=add.bind(SECTIONS),Section=e=>{if(isArray$1(e))throw TypeError$1("array can not be section, maybe you want to use it on the tables in it");return beSection(e),deInline(e),e},INLINE=!0,tables=new WeakSet$1,tables_add=add.bind(tables),isTable=has.bind(tables),implicitTables=new WeakSet$1,implicitTables_add=add.bind(implicitTables),implicitTables_del=del.bind(implicitTables),directlyIfNot=e=>!!implicitTables_del(e)&&(beSection(e),!0),DIRECTLY=!0,IMPLICITLY=!1,pairs=new WeakSet$1,pairs_add=add.bind(pairs),fromPair=has.bind(pairs),PAIR=!0,PlainTable=Null$1(class extends Null$1{constructor(e,t){return super(),tables_add(this),e?t?beInline(this,!0):beSection(this):(t?pairs_add:implicitTables_add)(this),this}}),OrderedTable=Null$1(class extends Null{constructor(e,t){return super(),tables_add(this),e?t?beInline(this,!0):beSection(this):(t?pairs_add:implicitTables_add)(this),this}}),NONE=[];let sourcePath="",sourceLines=NONE,lastLineIndex=-1,lineIndex=-1;const throws=e=>{throw e},EOL=/\r?\n/,todo=(e,t)=>{if("string"!=typeof t)throw TypeError$1("TOML.parse({ path })");sourcePath=t,sourceLines=e.split(EOL),lastLineIndex=sourceLines.length-1,lineIndex=-1},next=()=>sourceLines[++lineIndex],rest=()=>lineIndex!==lastLineIndex;class mark{lineIndex=lineIndex;type;restColumn;constructor(e,t){return this.type=e,this.restColumn=t,this}must(){return lineIndex===lastLineIndex&&throws(SyntaxError$1(`${this.type} is not close until the end of the file`+where(", which started from ",this.lineIndex,sourceLines[this.lineIndex].length-this.restColumn+1))),sourceLines[++lineIndex]}nowrap(e){throw throws(Error$1(`TOML.parse(${e?`${e}multilineStringJoiner`:",{ joiner }"}) must be passed, while the source including multi-line string`+where(", which started from ",this.lineIndex,sourceLines[this.lineIndex].length-this.restColumn+1)))}}const where=(e,t=lineIndex,r=0)=>sourceLines===NONE?"":sourcePath?`\n    at (${sourcePath}:${t+1}:${r})`:`${e}line ${t+1}: ${sourceLines[t]}`,done=()=>{sourcePath="",sourceLines=NONE},Whitespace=/[ \t]/,PRE_WHITESPACE=newRegExp`
	^${Whitespace}+`.valueOf(),{exec:VALUE_REST_exec}=newRegExp.s`
	^
	(
		(?:\d\d\d\d-\d\d-\d\d \d)?
		[\w\-+.:]+
	)
	${Whitespace}*
	(.*)
	$`.valueOf(),{exec:LITERAL_STRING_exec}=newRegExp.s`
	^
	'([^']*)'
	${Whitespace}*
	(.*)`.valueOf(),{exec:MULTI_LINE_LITERAL_STRING_0_1_2}=newRegExp.s`
	^
	(.*?)
	'''('{0,2})
	${Whitespace}*
	(.*)`.valueOf(),{exec:MULTI_LINE_LITERAL_STRING_0}=newRegExp.s`
	^
	(.*?)
	'''()
	${Whitespace}*
	(.*)`.valueOf();let __MULTI_LINE_LITERAL_STRING_exec=MULTI_LINE_LITERAL_STRING_0;const SYM_WHITESPACE=newRegExp.s`
	^
	.
	${Whitespace}*`.valueOf(),Tag=/[^\x00-\x1F"#'()<>[\\\]`{}\x7F]+/,{exec:KEY_VALUE_PAIR_exec}=newRegExp.s`
	^
	${Whitespace}*
	=
	${Whitespace}*
	(?:
		<(${Tag})>
		${Whitespace}*
	)?
	(.*)
	$`.valueOf(),{exec:_VALUE_PAIR_exec}=newRegExp.s`
	^
	<(${Tag})>
	${Whitespace}*
	(.*)
	$`.valueOf(),{exec:TAG_REST_exec}=newRegExp.s`
	^
	<(${Tag})>
	${Whitespace}*
	(.*)
	$`.valueOf(),MULTI_LINE_BASIC_STRING=theRegExp(/[^\\"]+|\\.?|"(?!"")"?/sy),MULTI_LINE_BASIC_STRING_exec_0_length=e=>{let t=0;for(;MULTI_LINE_BASIC_STRING.test(e);)t=MULTI_LINE_BASIC_STRING.lastIndex;return t},ESCAPED_EXCLUDE_CONTROL_CHARACTER_TAB______=/[^\\\x00-\x08\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|[\t ]*\n[\t\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g,ESCAPED_EXCLUDE_CONTROL_CHARACTER__________=/[^\\\x00-\x09\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|[\t ]*\n[\t\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g,ESCAPED_EXCLUDE_CONTROL_CHARACTER_DEL______=/[^\\\x00-\x09\x0B-\x1F]+|\\(?:[btnfr"\\]|[\t ]*\n[\t\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g,ESCAPED_EXCLUDE_CONTROL_CHARACTER_DEL_SLASH=/[^\\\x00-\x09\x0B-\x1F]+|\\(?:[btnfr"\\/]|[\t ]*\n[\t\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g;let __ESCAPED_EXCLUDE_CONTROL_CHARACTER=ESCAPED_EXCLUDE_CONTROL_CHARACTER_TAB______;const ESCAPED_EXCLUDE_CONTROL_CHARACTER_test=e=>!e.replace(__ESCAPED_EXCLUDE_CONTROL_CHARACTER,""),BASIC_STRING_TAB______=theRegExp(/[^\\"\x00-\x08\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/y),BASIC_STRING__________=theRegExp(/[^\\"\x00-\x08\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/y),BASIC_STRING_DEL______=theRegExp(/[^\\"\x00-\x08\x0B-\x1F]+|\\(?:[btnfr"\\]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/y),BASIC_STRING_DEL_SLASH=theRegExp(/[^\\"\x00-\x08\x0B-\x1F]+|\\(?:[btnfr"\\/]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/y);let __BASIC_STRING=BASIC_STRING_DEL_SLASH;const BASIC_STRING_exec_1_endIndex=e=>{let t=__BASIC_STRING.lastIndex=1;for(;__BASIC_STRING.test(e);)t=__BASIC_STRING.lastIndex;return t!==e.length&&'"'===e[t]||throws(SyntaxError$1("Bad basic string"+where(" at "))),t},{test:IS_DOT_KEY}=theRegExp(/^[ \t]*\./),DOT_KEY=/^[ \t]*\.[ \t]*/,{exec:BARE_KEY_STRICT}=theRegExp(/^[\w-]+/),{exec:BARE_KEY_FREE}=theRegExp(/^[^ \t#=[\]'".]+(?:[ \t]+[^ \t#=[\]'".]+)*/);let __BARE_KEY_exec=BARE_KEY_FREE;const{exec:LITERAL_KEY____}=theRegExp(/^'[^'\x00-\x08\x0B-\x1F\x7F]*'/),{exec:LITERAL_KEY_DEL}=theRegExp(/^'[^'\x00-\x08\x0B-\x1F]*'/);let __LITERAL_KEY_exec=LITERAL_KEY_DEL,supportArrayOfTables=!0;const TABLE_DEFINITION_exec_groups=(e,t)=>{const r="["===e[1];r?(supportArrayOfTables||throws(SyntaxError$1("Array of Tables is not allowed before TOML v0.2"+where(", which at "))),e=e.slice(2)):e=e.slice(1),e=e.replace(PRE_WHITESPACE,"");const{leadingKeys:n,finalKey:i}=({lineRest:e}=t(e));let a;return(e=e.replace(PRE_WHITESPACE,""))&&"]"===e[0]||throws(SyntaxError$1("Table header is not closed"+where(", which is found at "))),(e.length>1?"]"===e[1]===r:!r)||throws(SyntaxError$1("Square brackets of Table definition statement not match"+where(" at "))),(e=e.slice(r?2:1).replace(PRE_WHITESPACE,""))&&"<"===e[0]?({1:a,2:e}=TAG_REST_exec(e)||throws(SyntaxError$1("Bad tag"+where(" at ")))):a="",{leadingKeys:n,finalKey:i,asArrayItem:r,tag:a,lineRest:e}},KEY_VALUE_PAIR_exec_groups=({leadingKeys:e,finalKey:t,lineRest:r})=>{const{1:n=""}=({2:r}=KEY_VALUE_PAIR_exec(r)||throws(SyntaxError$1("Keys must equal something"+where(", but missing at "))));return n||r&&"#"!==r[0]||throws(SyntaxError$1("Value can not be missing after euqal sign"+where(", which is found at "))),{leadingKeys:e,finalKey:t,tag:n,lineRest:r}},{test:CONTROL_CHARACTER_EXCLUDE_TAB____}=theRegExp(/[\x00-\x08\x0B-\x1F\x7F]/),{test:CONTROL_CHARACTER_EXCLUDE_TAB_DEL}=theRegExp(/[\x00-\x08\x0B-\x1F]/);let __CONTROL_CHARACTER_EXCLUDE_test=CONTROL_CHARACTER_EXCLUDE_TAB____;const switchRegExp=e=>{switch(e){case 1:__MULTI_LINE_LITERAL_STRING_exec=MULTI_LINE_LITERAL_STRING_0_1_2,__LITERAL_KEY_exec=LITERAL_KEY____,__CONTROL_CHARACTER_EXCLUDE_test=CONTROL_CHARACTER_EXCLUDE_TAB____,__ESCAPED_EXCLUDE_CONTROL_CHARACTER=ESCAPED_EXCLUDE_CONTROL_CHARACTER_TAB______,__BASIC_STRING=BASIC_STRING_TAB______,__BARE_KEY_exec=BARE_KEY_STRICT,supportArrayOfTables=!0;break;case.5:__MULTI_LINE_LITERAL_STRING_exec=MULTI_LINE_LITERAL_STRING_0,__LITERAL_KEY_exec=LITERAL_KEY____,__CONTROL_CHARACTER_EXCLUDE_test=CONTROL_CHARACTER_EXCLUDE_TAB____,__ESCAPED_EXCLUDE_CONTROL_CHARACTER=ESCAPED_EXCLUDE_CONTROL_CHARACTER__________,__BASIC_STRING=BASIC_STRING__________,__BARE_KEY_exec=BARE_KEY_STRICT,supportArrayOfTables=!0;break;case.4:__MULTI_LINE_LITERAL_STRING_exec=MULTI_LINE_LITERAL_STRING_0,__LITERAL_KEY_exec=LITERAL_KEY_DEL,__CONTROL_CHARACTER_EXCLUDE_test=CONTROL_CHARACTER_EXCLUDE_TAB_DEL,__ESCAPED_EXCLUDE_CONTROL_CHARACTER=ESCAPED_EXCLUDE_CONTROL_CHARACTER_DEL______,__BASIC_STRING=BASIC_STRING_DEL______,__BARE_KEY_exec=BARE_KEY_STRICT,supportArrayOfTables=!0;break;default:__MULTI_LINE_LITERAL_STRING_exec=MULTI_LINE_LITERAL_STRING_0,__LITERAL_KEY_exec=LITERAL_KEY_DEL,__CONTROL_CHARACTER_EXCLUDE_test=CONTROL_CHARACTER_EXCLUDE_TAB_DEL,__ESCAPED_EXCLUDE_CONTROL_CHARACTER=ESCAPED_EXCLUDE_CONTROL_CHARACTER_DEL_SLASH,__BASIC_STRING=BASIC_STRING_DEL_SLASH,__BARE_KEY_exec=BARE_KEY_FREE,supportArrayOfTables=!1}},NUM=newRegExp`
	(?:
		0
		(?:
			b[01][_01]*
		|
			o[0-7][_0-7]*
		|
			x[\dA-Fa-f][_\dA-Fa-f]*
		|
			(?:\.\d[_\d]*)?(?:[Ee]-?\d[_\d]*)?
		)
	|
		[1-9][_\d]*
		(?:\.\d[_\d]*)?(?:[Ee]-?\d[_\d]*)?
	|
		inf
	|
		nan
	)
`.valueOf(),{test:IS_AMAZING}=newRegExp`
	^(?:
		-?${NUM}
		(?:-${NUM})*
	|
		true
	|
		false
	)$
`.valueOf(),{test:BAD_DXOB}=newRegExp`_(?![\dA-Fa-f])`.valueOf(),isAmazing=e=>IS_AMAZING(e)&&!BAD_DXOB(e);let mustScalar=!0,ARGS_MODE="",useWhatToJoinMultilineString=null,usingBigInt=!0,IntegerMinNumber=0,IntegerMaxNumber=0;const ANY={test:()=>!0},Keys=class extends RegExp$1{constructor(e){super(`^${groupify(e)}$`);let t=-1;for(let r=e.length;r;){const{length:n}=e[--r];n>t&&(t=n)}return this.lastIndex=t+1,this}test(e){return e.length<this.lastIndex&&super.test(e)}},isKeys=isPrototypeOf.bind(freeze(Keys.prototype));let preserveLiteral,zeroDatetime,inlineTable,moreDatetime,disallowEmptyKey,sError,sFloat,Table,allowLonger,enableNull,allowInlineTableMultilineAndTrailingCommaEvenNoComma,preserveComment,disableDigit,KEYS$1=ANY;const arrayTypes=new WeakMap$1,arrayTypes_get=get.bind(arrayTypes),arrayTypes_set=set.bind(arrayTypes),As=()=>{const e=t=>{const r=arrayTypes_get(t);return r?r===e||throws(TypeError$1("Types in Array must be same"+where(". Check "))):arrayTypes_set(t,e),t};return e},AS_TYPED={asNulls:As(),asStrings:As(),asTables:As(),asArrays:As(),asBooleans:As(),asFloats:As(),asIntegers:As(),asOffsetDateTimes:As(),asLocalDateTimes:As(),asLocalDates:As(),asLocalTimes:As()},asMixed=e=>e;let asNulls,asStrings,asTables,asArrays,asBooleans,asFloats,asIntegers,asOffsetDateTimes,asLocalDateTimes,asLocalDates,asLocalTimes,processor=null,each=null;const collect_on=(e,t,r,n)=>{const i=create$1(NULL);i._linked=each,i.tag=e,r&&(i.table=r,i.key=n),t&&(i.array=t,i.index=t.length),each=i},collect_off=()=>{throw throws(SyntaxError$1("xOptions.tag is not enabled, but found tag syntax"+where(" at ")))};let collect=collect_off;const Process=()=>{if(each){const e=processor;let t=each;return each=null,()=>{const r=e;let n=t;t=null;do{r(n)}while(n=n._linked)}}return null},clear=()=>{KEYS$1=ANY,useWhatToJoinMultilineString=processor=each=null,zeroDatetime=!1},use=(e,t,r,n,i,a)=>{let s;switch(ARGS_MODE=a,e){case 1:mustScalar=s=moreDatetime=sFloat=inlineTable=!0,zeroDatetime=disallowEmptyKey=!1;break;case.5:mustScalar=moreDatetime=sFloat=inlineTable=!0,s=zeroDatetime=disallowEmptyKey=!1;break;case.4:mustScalar=disallowEmptyKey=inlineTable=!0,s=zeroDatetime=moreDatetime=sFloat=!1;break;case.3:mustScalar=disallowEmptyKey=!0,s=zeroDatetime=moreDatetime=sFloat=inlineTable=!1;break;case.2:case.1:zeroDatetime=disallowEmptyKey=!0,mustScalar=s=moreDatetime=sFloat=inlineTable=!1;break;default:throw RangeError$1("TOML.parse(,specificationVersion)")}if(switchRegExp(e),"string"==typeof t)useWhatToJoinMultilineString=t;else{if(t!==undefined$1)throw TypeError$1(`TOML.parse(${ARGS_MODE?`${ARGS_MODE}multilineStringJoiner`:",{ joiner }"})`);useWhatToJoinMultilineString=null}if(r===undefined$1||!0===r)usingBigInt=!0;else if(!1===r)usingBigInt=!1;else{if("number"!=typeof r)throw TypeError$1(`TOML.parse(${ARGS_MODE?`${ARGS_MODE},useBigInt`:",{ bigint }"})`);if(!isSafeInteger(r))throw RangeError$1(`TOML.parse(${ARGS_MODE?`${ARGS_MODE},useBigInt`:",{ bigint }"})`);usingBigInt=null,r>=0?IntegerMinNumber=-(IntegerMaxNumber=r):IntegerMaxNumber=-(IntegerMinNumber=r)-1}if(!BigInt$1&&!1!==usingBigInt)throw Error$1(`Can't work without TOML.parse(${ARGS_MODE?`${ARGS_MODE},useBigInt`:",{ bigint }"}) being set to false, because the host doesn't have BigInt support`);if(null==n)KEYS$1=ANY;else{if(!isKeys(n))throw TypeError$1("TOML.parse(,{ keys })");KEYS$1=n}if(null==i)Table=PlainTable,sError=allowLonger=enableNull=allowInlineTableMultilineAndTrailingCommaEvenNoComma=!1,collect=collect_off;else{if("object"!=typeof i)throw TypeError$1(`TOML.parse(${ARGS_MODE?`${ARGS_MODE},,xOptions`:",{ x }"})`);{const{order:e,longer:t,exact:r,null:n,multi:a,comment:l,string:o,literal:c,tag:u,..._}=i,E=getOwnPropertyNames(_);if(E.length)throw TypeError$1(`TOML.parse(${ARGS_MODE?`${ARGS_MODE},,{ ${E.join(", ")} }`:`,{ x: { ${E.join(", ")} } }`})`);if(Table=e?OrderedTable:PlainTable,allowLonger=!t,sError=!!r,enableNull=!!n,allowInlineTableMultilineAndTrailingCommaEvenNoComma=!!a,preserveComment=!!l,disableDigit=!!o,preserveLiteral=!!c,u){if("function"!=typeof u)throw TypeError$1(`TOML.parse(${ARGS_MODE?`${ARGS_MODE},,{ tag }`:",{ x: { tag } }"})`);if(!s)throw TypeError$1(`TOML.parse(${ARGS_MODE?`${ARGS_MODE},,xOptions`:",{ x }"}) xOptions.tag needs at least TOML 1.0 to support mixed type array`);processor=u,collect=collect_on}else collect=collect_off}}s?asNulls=asStrings=asTables=asArrays=asBooleans=asFloats=asIntegers=asOffsetDateTimes=asLocalDateTimes=asLocalDates=asLocalTimes=asMixed:({asNulls,asStrings,asTables,asArrays,asBooleans,asFloats,asIntegers,asOffsetDateTimes,asLocalDateTimes,asLocalDates,asLocalTimes}=AS_TYPED)},isView=ArrayBuffer.isView,isArrayBuffer=function(){if("function"==typeof ArrayBuffer){var e=apply.bind(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype,"byteLength").get);return function(t){try{e(t)}catch(r){return!1}return!0}}return function(){return!1}}(),TextDecoder$1=TextDecoder,Symbol$1=Symbol,previous=Symbol$1("previous"),x=e=>{let t=e,r=t.next();if(!r.done)for(r.value[previous]=t,r=(t=r.value).next();;)if(r.done){if(t===e)break;t=t[previous],r=t.next(r.value)}else r.value[previous]=t,r=(t=r.value).next();return r.value},_literal=Symbol$1("_literal"),LiteralObject=(e,t)=>{const r=Object$1(t);return r[_literal]=e,r},arrays=new WeakSet$1,arrays_add=add.bind(arrays),isArray=has.bind(arrays),OF_TABLES=!1,STATICALLY=!0,staticalArrays=new WeakSet$1,staticalArrays_add=add.bind(staticalArrays),isStatic=has.bind(staticalArrays),newArray=e=>{const t=[];return arrays_add(t),e&&staticalArrays_add(t),t},NativeDate=Date,parse$2=Date.parse,preventExtensions=Object.preventExtensions,getOwnPropertyDescriptors=Object.getOwnPropertyDescriptors,defineProperties=function(e,t){for(var r=create$1(NULL),n=keys(t),i=n.length,a=0;a<i;++a){var s=n[a];r[s]=Descriptor(t[s])}if(getOwnPropertySymbols){var l=getOwnPropertySymbols(t);for(i=l.length,a=0;a<i;++a){var o=l[a];isEnum(t,o)&&(r[o]=Descriptor(t[o]))}}return Object_defineProperties(e,r)},fpc=e=>(freeze(freeze(e).prototype),e),_29_=/(?:0[1-9]|1\d|2\d)/,_30_=/(?:0[1-9]|[12]\d|30)/,_31_=/(?:0[1-9]|[12]\d|3[01])/,_23_=/(?:[01]\d|2[0-3])/,_59_=/[0-5]\d/,YMD=newRegExp`
	\d\d\d\d-
	(?:
		0
		(?:
			[13578]-${_31_}
			|
			[469]-${_30_}
			|
			2-${_29_}
		)
		|
		1
		(?:
			[02]-${_31_}
			|
			1-${_30_}
		)
	)
`.valueOf(),HMS=newRegExp`
	${_23_}:${_59_}:${_59_}
`.valueOf(),OFFSET$=/(?:[Zz]|[+-]\d\d:\d\d)$/,{exec:Z_exec}=theRegExp(/(([+-])\d\d):(\d\d)$/),{exec:OFFSET_DATETIME_exec}=newRegExp`
	^
	${YMD}
	[Tt ]
	${HMS}
	(?:\.\d{1,3}(\d*?)0*)?
	(?:[Zz]|[+-]${_23_}:${_59_})
	$`.valueOf(),{exec:OFFSET_DATETIME_ZERO_exec}=newRegExp`
	^
	${YMD}
	[Tt ]
	${HMS}
	()
	[Zz]
	$`.valueOf(),{test:IS_LOCAL_DATETIME}=newRegExp`
	^
	${YMD}
	[Tt ]
	${HMS}
	(?:\.\d+)?
	$`.valueOf(),{test:IS_LOCAL_DATE}=newRegExp`
	^
	${YMD}
	$`.valueOf(),{test:IS_LOCAL_TIME}=newRegExp`
	^
	${HMS}
	(?:\.\d+)?
	$`.valueOf(),T=/[ t]/,DELIMITER_DOT=/[-T:.]/g,DOT_ZERO=/\.?0+$/,ZERO=/\.(\d*?)0+$/,zeroReplacer=(e,t)=>t,Datetime=(()=>{const e=function(){return this},t=Null$1(null);{const e=Null$1(null);for(const r of ownKeys(NativeDate.prototype))"constructor"===r||"toJSON"===r||(t[r]=e)}return e.prototype=preventExtensions(create$1(NativeDate.prototype,t)),freeze(e)})(),Value=e=>e.replace(ZERO,zeroReplacer).replace(DELIMITER_DOT,""),d=/./gs,d2u=e=>"          "[e],ValueOFFSET=(e,t)=>e<0?(""+(e+6216730554e4)).replace(d,d2u).padStart(14," ")+t.replace(d,d2u)+e:t?(e+".").padStart(16,"0")+t:(""+e).padStart(15,"0"),validateLeap=e=>{if(e.startsWith("02-29",5)){const t=+e.slice(0,4);return!(3&t||!(t%100)&&(t%400||!(t%3200)))}return!0},{test:VALIDATE_LEAP}=newRegExp.s`^.....(?:06.30|12.31).23:59:59`.valueOf(),DATE$1=defineProperties(new NativeDate(0),getOwnPropertyDescriptors(NativeDate.prototype)),OffsetDateTime_ISOString=Symbol$1("OffsetDateTime_ISOString"),OffsetDateTime_value=Symbol$1("OffsetDateTime_value"),OffsetDateTime_use=(e,t=0)=>(DATE$1.setTime(+e[OffsetDateTime_value]+t),DATE$1),OffsetDateTime=fpc(class extends Datetime{[OffsetDateTime_ISOString];[OffsetDateTime_value];get[Symbol$1.toStringTag](){return"OffsetDateTime"}valueOf(){return this[OffsetDateTime_value]}toISOString(){return this[OffsetDateTime_ISOString]}constructor(e){validateLeap(e)||throws(SyntaxError$1(`Invalid Offset Date-Time ${e}`+where(" at ")));const t=e.startsWith("60",17);let r=t?e.slice(0,17)+"59"+e.slice(19):e;const{1:n=""}=(zeroDatetime?OFFSET_DATETIME_ZERO_exec(r):OFFSET_DATETIME_exec(r))||throws(SyntaxError$1(`Invalid Offset Date-Time ${e}`+where(" at "))),i=parse$2(r=r.replace(T,"T").replace("z","Z"));return t&&(DATE$1.setTime(i),VALIDATE_LEAP(DATE$1.toISOString())||throws(SyntaxError$1(`Invalid Offset Date-Time ${e}`+where(" at ")))),super(),this[OffsetDateTime_ISOString]=r,this[OffsetDateTime_value]=ValueOFFSET(i,n),this}getUTCFullYear(){return OffsetDateTime_use(this).getUTCFullYear()}getUTCMonth(){return OffsetDateTime_use(this).getUTCMonth()}getUTCDate(){return OffsetDateTime_use(this).getUTCDate()}getUTCHours(){return OffsetDateTime_use(this).getUTCHours()}getUTCMinutes(){return OffsetDateTime_use(this).getUTCMinutes()}getUTCSeconds(){return OffsetDateTime_use(this).getUTCSeconds()}getUTCMilliseconds(){return OffsetDateTime_use(this).getUTCMilliseconds()}getUTCDay(){return OffsetDateTime_use(this).getUTCDay()}getTimezoneOffset(){const e=Z_exec(this[OffsetDateTime_ISOString]);return e?60*+e[1]+ +(e[2]+e[3]):0}getTime(){return floor(+this[OffsetDateTime_value])}}),LocalDateTime_ISOString=Symbol$1("LocalDateTime_ISOString"),LocalDateTime_value=Symbol$1("LocalDateTime_value"),LocalDateTime_get=(e,t,r)=>+e[LocalDateTime_ISOString].slice(t,r),LocalDateTime_set=(e,t,r,n)=>{const i=""+n,a=r-t;if(i.length>a)throw RangeError$1();e[LocalDateTime_value]=Value(e[LocalDateTime_ISOString]=e[LocalDateTime_ISOString].slice(0,t)+i.padStart(a,"0")+e[LocalDateTime_ISOString].slice(r))},LocalDateTime=fpc(class extends Datetime{[LocalDateTime_ISOString];[LocalDateTime_value];get[Symbol$1.toStringTag](){return"LocalDateTime"}valueOf(){return this[LocalDateTime_value]}toISOString(){return this[LocalDateTime_ISOString]}constructor(e){return IS_LOCAL_DATETIME(e)&&validateLeap(e)||throws(SyntaxError$1(`Invalid Local Date-Time ${e}`+where(" at "))),super(),this[LocalDateTime_value]=Value(this[LocalDateTime_ISOString]=e.replace(T,"T")),this}getFullYear(){return LocalDateTime_get(this,0,4)}setFullYear(e){LocalDateTime_set(this,0,4,e)}getMonth(){return LocalDateTime_get(this,5,7)-1}setMonth(e){LocalDateTime_set(this,5,7,e+1)}getDate(){return LocalDateTime_get(this,8,10)}setDate(e){LocalDateTime_set(this,8,10,e)}getHours(){return LocalDateTime_get(this,11,13)}setHours(e){LocalDateTime_set(this,11,13,e)}getMinutes(){return LocalDateTime_get(this,14,16)}setMinutes(e){LocalDateTime_set(this,14,16,e)}getSeconds(){return LocalDateTime_get(this,17,19)}setSeconds(e){LocalDateTime_set(this,17,19,e)}getMilliseconds(){return+this[LocalDateTime_value].slice(14,17).padEnd(3,"0")}setMilliseconds(e){this[LocalDateTime_value]=Value(this[LocalDateTime_ISOString]=this[LocalDateTime_ISOString].slice(0,19)+(e?("."+(""+e).padStart(3,"0")).replace(DOT_ZERO,""):""))}}),LocalDate_ISOString=Symbol$1("LocalDate_ISOString"),LocalDate_value=Symbol$1("LocalDate_value"),LocalDate_get=(e,t,r)=>+e[LocalDate_ISOString].slice(t,r),LocalDate_set=(e,t,r,n)=>{const i=""+n,a=r-t;if(i.length>a)throw RangeError$1();e[LocalDate_value]=Value(e[LocalDate_ISOString]=e[LocalDate_ISOString].slice(0,t)+i.padStart(a,"0")+e[LocalDate_ISOString].slice(r))},LocalDate=fpc(class extends Datetime{[LocalDate_ISOString];[LocalDate_value];get[Symbol$1.toStringTag](){return"LocalDate"}valueOf(){return this[LocalDate_value]}toISOString(){return this[LocalDate_ISOString]}constructor(e){return IS_LOCAL_DATE(e)&&validateLeap(e)||throws(SyntaxError$1(`Invalid Local Date ${e}`+where(" at "))),super(),this[LocalDate_value]=Value(this[LocalDate_ISOString]=e),this}getFullYear(){return LocalDate_get(this,0,4)}setFullYear(e){LocalDate_set(this,0,4,e)}getMonth(){return LocalDate_get(this,5,7)-1}setMonth(e){LocalDate_set(this,5,7,e+1)}getDate(){return LocalDate_get(this,8,10)}setDate(e){LocalDate_set(this,8,10,e)}}),LocalTime_ISOString=Symbol$1("LocalTime_ISOString"),LocalTime_value=Symbol$1("LocalTime_value"),LocalTime_get=(e,t,r)=>+e[LocalTime_ISOString].slice(t,r),LocalTime_set=(e,t,r,n)=>{const i=""+n;if(i.length>r-t)throw RangeError$1();e[LocalTime_value]=Value(e[LocalTime_ISOString]=e[LocalTime_ISOString].slice(0,t)+i.padStart(2,"0")+e[LocalTime_ISOString].slice(r))},LocalTime=fpc(class extends Datetime{[LocalTime_ISOString];[LocalTime_value];get[Symbol$1.toStringTag](){return"LocalTime"}valueOf(){return this[LocalTime_value]}toISOString(){return this[LocalTime_ISOString]}constructor(e){return IS_LOCAL_TIME(e)||throws(SyntaxError$1(`Invalid Local Time ${e}`+where(" at "))),super(),this[LocalTime_value]=Value(this[LocalTime_ISOString]=e),this}getHours(){return LocalTime_get(this,0,2)}setHours(e){LocalTime_set(this,0,2,e)}getMinutes(){return LocalTime_get(this,3,5)}setMinutes(e){LocalTime_set(this,3,5,e)}getSeconds(){return LocalTime_get(this,6,8)}setSeconds(e){LocalTime_set(this,6,8,e)}getMilliseconds(){return+this[LocalTime_value].slice(6,9).padEnd(3,"0")}setMilliseconds(e){this[LocalTime_value]=Value(this[LocalTime_ISOString]=this[LocalTime_ISOString].slice(0,8)+(e?("."+(""+e).padStart(3,"0")).replace(DOT_ZERO,""):""))}}),parseInt$1=parseInt,fromCodePoint=String.fromCodePoint,ESCAPED_IN_SINGLE_LINE=/[^\\]+|\\(?:[\\"btnfr/]|u.{4}|U.{8})/gs,ESCAPED_IN_MULTI_LINE=/[^\n\\]+|\n|\\(?:[\t ]*\n[\t\n ]*|[\\"btnfr/]|u.{4}|U.{8})/gs,BasicString=e=>{if(!e)return"";const t=e.match(ESCAPED_IN_SINGLE_LINE),{length:r}=t;let n=0;do{const e=t[n];if("\\"===e[0])switch(e[1]){case"\\":t[n]="\\";break;case'"':t[n]='"';break;case"b":t[n]="\b";break;case"t":t[n]="\t";break;case"n":t[n]="\n";break;case"f":t[n]="\f";break;case"r":t[n]="\r";break;case"u":const r=parseInt$1(e.slice(2),16);mustScalar&&55295<r&&r<57344&&throws(RangeError$1(`Invalid Unicode Scalar ${e}`+where(" at "))),t[n]=fromCharCode(r);break;case"U":const i=parseInt$1(e.slice(2),16);(mustScalar&&55295<i&&i<57344||1114111<i)&&throws(RangeError$1(`Invalid Unicode Scalar ${e}`+where(" at "))),t[n]=fromCodePoint(i);break;case"/":t[n]="/"}}while(++n!==r);return t.join("")},MultilineBasicString=(e,t,r)=>{if(!e)return"";const n=e.match(ESCAPED_IN_MULTI_LINE),{length:i}=n;let a=0;do{const e=n[a];if("\n"===e)++r,n[a]=t;else if("\\"===e[0])switch(e[1]){case"\n":case" ":case"\t":for(let n=0;n=e.indexOf("\n",n)+1;)++r;n[a]="";break;case"\\":n[a]="\\";break;case'"':n[a]='"';break;case"b":n[a]="\b";break;case"t":n[a]="\t";break;case"n":n[a]="\n";break;case"f":n[a]="\f";break;case"r":n[a]="\r";break;case"u":const t=parseInt$1(e.slice(2),16);mustScalar&&55295<t&&t<57344&&throws(RangeError$1(`Invalid Unicode Scalar ${e}`+where(" at ",lineIndex+r))),n[a]=fromCharCode(t);break;case"U":const i=parseInt$1(e.slice(2),16);(mustScalar&&55295<i&&i<57344||1114111<i)&&throws(RangeError$1(`Invalid Unicode Scalar ${e}`+where(" at ",lineIndex+r))),n[a]=fromCodePoint(i);break;case"/":n[a]="/"}}while(++a!==i);return n.join("")},INTEGER_D=/[-+]?(?:0|[1-9][_\d]*)/,{test:BAD_D}=newRegExp`_(?!\d)`.valueOf(),{test:IS_D_INTEGER}=newRegExp`^${INTEGER_D}$`.valueOf(),{test:IS_XOB_INTEGER}=theRegExp(/^0(?:x[\dA-Fa-f][_\dA-Fa-f]*|o[0-7][_0-7]*|b[01][_01]*)$/),{test:BAD_XOB}=newRegExp`_(?![\dA-Fa-f])`.valueOf(),UNDERSCORES$1=/_/g,UNDERSCORES_SIGN=/_|^[-+]/g,IS_INTEGER=e=>(IS_D_INTEGER(e)||IS_XOB_INTEGER(e))&&!BAD_XOB(e),MIN=BigInt$1&&-BigInt$1("0x8000000000000000"),MAX=BigInt$1&&BigInt$1("0x7FFFFFFFFFFFFFFF"),BigIntInteger=e=>{IS_INTEGER(e)||throws(SyntaxError$1(`Invalid Integer ${e}`+where(" at ")));const t="-"===e[0]?-BigInt$1(e.replace(UNDERSCORES_SIGN,"")):BigInt$1(e.replace(UNDERSCORES_SIGN,""));return allowLonger||MIN<=t&&t<=MAX||throws(RangeError$1(`Integer expect 64 bit range (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807), not includes ${e}`+where(" meet at "))),t},NumberInteger=e=>{IS_INTEGER(e)||throws(SyntaxError$1(`Invalid Integer ${e}`+where(" at ")));const t=parseInt$1(e.replace(UNDERSCORES$1,""));return isSafeInteger(t)||throws(RangeError$1(`Integer did not use BitInt must fit Number.isSafeInteger, not includes ${e}`+where(" meet at "))),t},Integer=e=>{if(!0===usingBigInt)return BigIntInteger(e);if(!1===usingBigInt)return NumberInteger(e);IS_INTEGER(e)||throws(SyntaxError$1(`Invalid Integer ${e}`+where(" at ")));const t=parseInt$1(e.replace(UNDERSCORES$1,""));if(IntegerMinNumber<=t&&t<=IntegerMaxNumber)return t;const r="-"===e[0]?-BigInt$1(e.replace(UNDERSCORES_SIGN,"")):BigInt$1(e.replace(UNDERSCORES_SIGN,""));return allowLonger||MIN<=r&&r<=MAX||throws(RangeError$1(`Integer expect 64 bit range (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807), not includes ${e}`+where(" meet at "))),r},isFinite$1=isFinite,NaN$1=NaN,_NaN=NaN,_Infinity$1=-1/0,{test:IS_FLOAT}=newRegExp`
	^
	${INTEGER_D}
	(?:
		\.\d[_\d]*
		(?:[eE][-+]?\d[_\d]*)?
	|
		[eE][-+]?\d[_\d]*
	)
	$`.valueOf(),UNDERSCORES=/_/g,{test:IS_ZERO}=theRegExp(/^[-+]?0(?:\.0+)?(?:[eE][-+]?0+)?$/),{exec:NORMALIZED}=theRegExp(/^[-0]?(\d*)(?:\.(\d+))?(?:e\+?(-?\d+))?$/),{exec:ORIGINAL}=theRegExp(/^[-+]?0?(\d*)(?:\.(\d*?)0*)?(?:[eE]\+?(-?\d+))?$/),Float=e=>{if(!IS_FLOAT(e)||BAD_D(e)){if(sFloat){if("inf"===e||"+inf"===e)return 1/0;if("-inf"===e)return-1/0;if("nan"===e||"+nan"===e)return NaN;if("-nan"===e)return NaN}throw throws(SyntaxError$1(`Invalid Float ${e}`+where(" at ")))}const t=e.replace(UNDERSCORES,""),r=+t;if(sError){isFinite$1(r)||throws(RangeError$1(`Float ${e} has been as big as inf`+where(" at "))),r||IS_ZERO(t)||throws(RangeError$1(`Float ${e} has been as little as ${"-"===e[0]?"-":""}0`+where(" at ")));const{1:n,2:i="",3:a=""}=NORMALIZED(r),{1:s,2:l="",3:o=""}=ORIGINAL(t);s+l===n+i&&o-l.length==a-i.length||throws(RangeError$1(`Float ${e} has lost its exact and been ${r}`+where(" at ")))}return r},prepareTable=(e,t)=>{const{length:r}=t;let n=0;for(;n<r;){const i=t[n++];if(!(i in e)){for(e=e[i]=new Table(!1);n<r;)e=e[t[n++]]=new Table(!1);return e}if(isTable(e=e[i]))isInline(e)&&throws(Error$1("Trying to define Table under Inline Table"+where(" at ")));else{if(!isArray(e))throw throws(Error$1("Trying to define Table under non-Table value"+where(" at ")));isStatic(e)&&throws(Error$1("Trying to append value to Static Array"+where(" at "))),e=e[e.length-1]}}return e},appendTable=(e,t,r,n)=>{let i;if(r){let r;t in e?isArray(r=e[t])&&!isStatic(r)||throws(Error$1("Trying to push Table to non-ArrayOfTables value"+where(" at "))):r=e[t]=newArray(!1),n&&collect(n,r,e,t),r[r.length]=i=new Table(!0)}else t in e?(i=e[t],fromPair(i)&&throws(Error$1("A table defined implicitly via key/value pair can not be accessed to via []"+where(", which at "))),directlyIfNot(i)||throws(Error$1("Duplicate Table definition"+where(" at ")))):e[t]=i=new Table(!0),n&&collect(n,null,e,t);return i},prepareInlineTable=(e,t)=>{const{length:r}=t;let n=0;for(;n<r;){const i=t[n++];if(!(i in e)){for(e=e[i]=new Table(!1,!0);n<r;)e=e[t[n++]]=new Table(!1,!0);return e}isTable(e=e[i])||throws(Error$1("Trying to assign property through non-Table value"+where(" at "))),isInline(e)&&throws(Error$1("Trying to assign property through static Inline Table"+where(" at "))),fromPair(e)||throws(Error$1("A table defined implicitly via [] can not be accessed to via key/value pair"+where(", which at ")))}return e},checkLiteralString=e=>(__CONTROL_CHARACTER_EXCLUDE_test(e)&&throws(SyntaxError$1("Control characters other than Tab are not permitted in a Literal String"+where(", which was found at "))),e),assignLiteralString=(e,t,r)=>{if(!r.startsWith("'''")){const n=LITERAL_STRING_exec(r)||throws(SyntaxError$1("Bad literal string"+where(" at "))),i=checkLiteralString(n[1]);return e[t]=preserveLiteral?LiteralObject(r.slice(0,i.length+2),i):i,n[2]}const n=__MULTI_LINE_LITERAL_STRING_exec(r.slice(3));if(n){const i=checkLiteralString(n[1])+n[2];return e[t]=preserveLiteral?LiteralObject(r.slice(0,i.length+6),i):i,n[3]}const i=new mark("Multi-line Literal String",r.length),a=!(r=r.slice(3));if(a){r=i.must();const n=__MULTI_LINE_LITERAL_STRING_exec(r);if(n){const i=checkLiteralString(n[1])+n[2];return e[t]=preserveLiteral?LiteralObject(["'''",r.slice(0,i.length+3)],i):i,n[3]}}null===useWhatToJoinMultilineString&&i.nowrap(ARGS_MODE);for(const s=[checkLiteralString(r)];;){const n=i.must(),l=__MULTI_LINE_LITERAL_STRING_exec(n);if(l){s[s.length]=checkLiteralString(l[1])+l[2];const n=s.join(useWhatToJoinMultilineString);return preserveLiteral?(s[s.length-1]+="'''",a?s.unshift("'''"):s[0]=`'''${r}`,e[t]=LiteralObject(s,n)):e[t]=n,l[3]}s[s.length]=checkLiteralString(n)}},assignBasicString=(e,t,r)=>{if(!r.startsWith('"""')){const n=BASIC_STRING_exec_1_endIndex(r),i=BasicString(r.slice(1,n));return e[t]=preserveLiteral?LiteralObject(r.slice(0,n+1),i):i,r.slice(n+1).replace(PRE_WHITESPACE,"")}let n=3+MULTI_LINE_BASIC_STRING_exec_0_length(r.slice(3));if(r.length!==n){const i=r.slice(3,n);ESCAPED_EXCLUDE_CONTROL_CHARACTER_test(i)||throws(SyntaxError$1("Bad multi-line basic string"+where(" at ")));const a=BasicString(i)+(r.startsWith('"',n+=3)?r.startsWith('"',++n)?(++n,'""'):'"':"");return e[t]=preserveLiteral?LiteralObject(r.slice(0,n),a):a,r.slice(n).replace(PRE_WHITESPACE,"")}const i=new mark("Multi-line Basic String",n),a=(r=r.slice(3))?0:1;if(a){r=i.must();let n=MULTI_LINE_BASIC_STRING_exec_0_length(r);if(r.length!==n){const i=r.slice(0,n);ESCAPED_EXCLUDE_CONTROL_CHARACTER_test(i)||throws(SyntaxError$1("Bad multi-line basic string"+where(" at ")));const s=MultilineBasicString(i,useWhatToJoinMultilineString,a)+(r.startsWith('"',n+=3)?r.startsWith('"',++n)?(++n,'""'):'"':"");return e[t]=preserveLiteral?LiteralObject(['"""',r.slice(0,n)],s):s,r.slice(n).replace(PRE_WHITESPACE,"")}}null===useWhatToJoinMultilineString&&i.nowrap(ARGS_MODE),ESCAPED_EXCLUDE_CONTROL_CHARACTER_test(r+"\n")||throws(SyntaxError$1("Bad multi-line basic string"+where(" at ")));for(const s=[r];;){const n=i.must();let l=MULTI_LINE_BASIC_STRING_exec_0_length(n);if(n.length!==l){const i=n.slice(0,l);ESCAPED_EXCLUDE_CONTROL_CHARACTER_test(i)||throws(SyntaxError$1("Bad multi-line basic string"+where(" at ")));const o=MultilineBasicString(s.join("\n")+"\n"+i,useWhatToJoinMultilineString,a)+(n.startsWith('"',l+=3)?n.startsWith('"',++l)?(++l,'""'):'"':"");return preserveLiteral?(a?s.unshift('"""'):s[0]=`"""${r}`,s[s.length]=`${i}"""`,e[t]=LiteralObject(s,o)):e[t]=o,n.slice(l).replace(PRE_WHITESPACE,"")}ESCAPED_EXCLUDE_CONTROL_CHARACTER_test(n+"\n")||throws(SyntaxError$1("Bad multi-line basic string"+where(" at "))),s[s.length]=n}},KEYS=Null$1(null),commentFor=e=>KEYS[e]||(KEYS[e]=Symbol$1(e)),commentForThis=Symbol$1("this"),{test:includesNewline}=theRegExp(/\r?\n/g),getCOMMENT=(e,t)=>{if(t in e){const r=e[t];if("string"!=typeof r)throw TypeError$1(`the value of comment must be a string, while "${null===r?"null":typeof r}" type is found`);if(includesNewline(r))throw SyntaxError$1("the value of comment must be a string and can not include newline");return` #${r}`}return""},getComment=(e,t)=>t in KEYS?getCOMMENT(e,KEYS[t]):"",{test:IS_OFFSET$}=theRegExp(OFFSET$),{test:IS_EMPTY}=theRegExp(/^\[[\t ]*]/),parseKeys=e=>{let t=e;const r=[];let n=-1;for(;;){if(t||throws(SyntaxError$1("Empty bare key"+where(" at "))),'"'===t[0]){const e=BASIC_STRING_exec_1_endIndex(t);KEYS$1.test(r[++n]=BasicString(t.slice(1,e)))||throws(Error$1("Key not allowed"+where(" at "))),t=t.slice(e+1)}else{const e="'"===t[0],i=((e?__LITERAL_KEY_exec:__BARE_KEY_exec)(t)||throws(SyntaxError$1(`Bad ${e?"literal string":"bare"} key`+where(" at "))))[0];t=t.slice(i.length),KEYS$1.test(r[++n]=e?i.slice(1,-1):i)||throws(Error$1("Key not allowed"+where(" at ")))}if(!IS_DOT_KEY(t))break;t=t.replace(DOT_KEY,"")}if(disableDigit){const r=e.slice(0,-t.length);(isAmazing(r)||enableNull&&"null"===r)&&throws(SyntaxError$1("Bad bare key disabled by xOptions.string"+where(" at ")))}if(disallowEmptyKey){let e=n;do{r[e]||throws(SyntaxError$1("Empty key is not allowed before TOML v0.5"+where(", which at ")))}while(e--)}const i=r[n];return r.length=n,{leadingKeys:r,finalKey:i,lineRest:t}},push=(e,t)=>{if("<"===t[0]){const{1:r}=({2:t}=_VALUE_PAIR_exec(t)||throws(SyntaxError$1("Bad tag "+where(" at "))));switch(collect(r,e,null),t&&t[0]){case",":case"]":case"":case"#":return e[e.length]=undefined$1,t}}switch(t[0]){case"'":return assignLiteralString(asStrings(e),e.length,t);case'"':return assignBasicString(asStrings(e),e.length,t);case"{":return inlineTable||throws(SyntaxError$1("Inline Table is not allowed before TOML v0.4"+where(", which at "))),equalInlineTable(asTables(e),e.length,t);case"[":return equalStaticArray(asArrays(e),e.length,t)}const{1:r}=({2:t}=VALUE_REST_exec(t)||throws(SyntaxError$1("Bad atom value"+where(" at "))));return"true"===r?asBooleans(e)[e.length]=!0:"false"===r?asBooleans(e)[e.length]=!1:enableNull&&"null"===r?asNulls(e)[e.length]=null:r.includes(":")?r.includes("-")?IS_OFFSET$(r)?asOffsetDateTimes(e)[e.length]=new OffsetDateTime(r):(moreDatetime||throws(SyntaxError$1("Local Date-Time is not allowed before TOML v0.5"+where(", which at "))),asLocalDateTimes(e)[e.length]=new LocalDateTime(r)):(moreDatetime||throws(SyntaxError$1("Local Time is not allowed before TOML v0.5"+where(", which at "))),asLocalTimes(e)[e.length]=new LocalTime(r)):r.indexOf("-")!==r.lastIndexOf("-")&&"-"!==r[0]?(moreDatetime||throws(SyntaxError$1("Local Date is not allowed before TOML v0.5"+where(", which at "))),asLocalDates(e)[e.length]=new LocalDate(r)):r.includes(".")||r.includes("n")||(r.includes("e")||r.includes("E"))&&!r.startsWith("0x")?asFloats(e)[e.length]=preserveLiteral?LiteralObject(r,Float(r)):Float(r):asIntegers(e)[e.length]=preserveLiteral?LiteralObject(r,Integer(r)):Integer(r),t},equalStaticArray=function*(e,t,r){const n=e[t]=newArray(!0);if(IS_EMPTY(r))return beInline(n,"]"===r[1]?0:3),r.slice(r.indexOf("]")).replace(SYM_WHITESPACE,"");const i=new mark("Static Array",r.length);let a=r.startsWith("[ ")||r.startsWith("[\t")?3:0;for(r=r.replace(SYM_WHITESPACE,"");!r||"#"===r[0];)a=null,r=i.must().replace(PRE_WHITESPACE,"");if("]"===r[0])return null===a||beInline(n,a),r.replace(SYM_WHITESPACE,"");for(;;){const e=push(n,r);for(r="string"==typeof e?e:yield e;!r||"#"===r[0];)a=null,r=i.must().replace(PRE_WHITESPACE,"");if(","!==r[0]){if("]"===r[0])break;throw throws(SyntaxError$1("Unexpect character in static array item value"+where(", which is found at ")))}for(r=r.replace(SYM_WHITESPACE,"");!r||"#"===r[0];)a=null,r=i.must().replace(PRE_WHITESPACE,"");if("]"===r[0])break}return null===a||beInline(n,a),r.replace(SYM_WHITESPACE,"")},equalInlineTable=function*(e,t,r){const n=e[t]=new Table(!0,!0);if(allowInlineTableMultilineAndTrailingCommaEvenNoComma){const e=new mark("Inline Table",r.length);r=r.replace(SYM_WHITESPACE,"");let t=!0;for(;;){for(;!r||"#"===r[0];)t=!1,r=e.must().replace(PRE_WHITESPACE,"");if("}"===r[0])break;const i=ForComment(n,r),a=assign(i);if(r="string"==typeof a?a:yield a,r){if("#"===r[0]){preserveComment&&(i.table[commentFor(i.finalKey)]=r.slice(1)),t=!1;do{r=e.must().replace(PRE_WHITESPACE,"")}while(!r||"#"===r[0])}}else{t=!1;do{r=e.must().replace(PRE_WHITESPACE,"")}while(!r||"#"===r[0])}","===r[0]&&(r=r.replace(SYM_WHITESPACE,""))}t||beInline(n,!1)}else if("}"!==(r=r.replace(SYM_WHITESPACE,"")||throws(SyntaxError$1("Inline Table is intended to appear on a single line"+where(", which broken at "))))[0])for(;;){"#"===r[0]&&throws(SyntaxError$1("Inline Table is intended to appear on a single line"+where(", which broken at ")));const e=assign(ForComment(n,r));if(r=("string"==typeof e?e:yield e)||throws(SyntaxError$1("Inline Table is intended to appear on a single line"+where(", which broken at "))),"}"===r[0])break;","===r[0]&&"}"===(r=r.replace(SYM_WHITESPACE,"")||throws(SyntaxError$1("Inline Table is intended to appear on a single line"+where(", which broken at "))))[0]&&throws(SyntaxError$1("The last property of an Inline Table can not have a trailing comma"+where(", which was found at ")))}return r.replace(SYM_WHITESPACE,"")},ForComment=(e,t)=>{const{leadingKeys:r,finalKey:n,tag:i}=({lineRest:t}=KEY_VALUE_PAIR_exec_groups(parseKeys(t)));return{table:prepareInlineTable(e,r),finalKey:n,tag:i,lineRest:t}},assign=({finalKey:e,tag:t,lineRest:r,table:n})=>{if(e in n&&throws(Error$1("Duplicate property definition"+where(" at "))),t)switch(collect(t,null,n,e),r&&r[0]){case",":case"}":case"":case"#":return n[e]=undefined$1,r}switch(r&&r[0]){case"'":return assignLiteralString(n,e,r);case'"':return assignBasicString(n,e,r);case"{":return inlineTable||throws(SyntaxError$1("Inline Table is not allowed before TOML v0.4"+where(", which at "))),equalInlineTable(n,e,r);case"[":return equalStaticArray(n,e,r)}const{1:i}=({2:r}=VALUE_REST_exec(r)||throws(SyntaxError$1("Bad atom value"+where(" at "))));return"true"===i?n[e]=!0:"false"===i?n[e]=!1:enableNull&&"null"===i?n[e]=null:i.includes(":")?i.includes("-")?IS_OFFSET$(i)?n[e]=new OffsetDateTime(i):(moreDatetime||throws(SyntaxError$1("Local Date-Time is not allowed before TOML v0.5"+where(", which at "))),n[e]=new LocalDateTime(i)):(moreDatetime||throws(SyntaxError$1("Local Time is not allowed before TOML v0.5"+where(", which at "))),n[e]=new LocalTime(i)):i.indexOf("-")!==i.lastIndexOf("-")&&"-"!==i[0]?(moreDatetime||throws(SyntaxError$1("Local Date is not allowed before TOML v0.5"+where(", which at "))),n[e]=new LocalDate(i)):n[e]=i.includes(".")||i.includes("n")||(i.includes("e")||i.includes("E"))&&!i.startsWith("0x")?preserveLiteral?LiteralObject(i,Float(i)):Float(i):preserveLiteral?LiteralObject(i,Integer(i)):Integer(i),r},Root=()=>{const e=new Table;let t=e;for(;lineIndex!==lastLineIndex;){const r=sourceLines[++lineIndex].replace(PRE_WHITESPACE,"");if(r)if("["===r[0]){const{leadingKeys:n,finalKey:i,asArrayItem:a,tag:s,lineRest:l}=TABLE_DEFINITION_exec_groups(r,parseKeys),o=prepareTable(e,n);l&&("#"===l[0]||throws(SyntaxError$1("Unexpect charachtor after table header"+where(" at ")))),t=appendTable(o,i,a,s),preserveComment&&l&&(t[commentForThis]=a?l.slice(1):o[commentFor(i)]=l.slice(1))}else if("#"===r[0])__CONTROL_CHARACTER_EXCLUDE_test(r)&&throws(SyntaxError$1("Control characters other than Tab are not permitted in comments"+where(", which was found at ")));else{const e=ForComment(t,r);let n=assign(e);"string"==typeof n||(n=x(n)),n&&("#"===n[0]||throws(SyntaxError$1("Unexpect charachtor after key/value pair"+where(" at "))),preserveComment&&(e.table[commentFor(e.finalKey)]=n.slice(1)))}}return e},MAX_SAFE_INTEGER=Number.MAX_SAFE_INTEGER,DATE=Date.prototype,valueOf$2=String.prototype.valueOf,isString=function(){if(apply.bind){var e=apply.bind(valueOf$2);return function(t){try{e(t)}catch(r){return!1}return!0}}return function(e){try{valueOf$2.apply(e)}catch(t){return!1}return!0}}(),valueOf$1=Number.prototype.valueOf,isNumber=function(){if(apply.bind){var e=apply.bind(valueOf$1);return function(t){try{e(t)}catch(r){return!1}return!0}}return function(e){try{valueOf$1.apply(e)}catch(t){return!1}return!0}}(),isBigInt=function(){if("function"==typeof BigInt){var e=apply.bind(BigInt.prototype.valueOf);return function(t){try{e(t)}catch(r){return!1}return!0}}return function(){return!1}}(),valueOf=BigInt.prototype.valueOf,isBoolean=function(){if(apply.bind){var e=apply.bind(valueOf);return function(t){try{e(t)}catch(r){return!1}return!0}}return function(e){try{valueOf.apply(e)}catch(t){return!1}return!0}}(),ESCAPED=Null$1({...fromEntries([...Array$1(32)].map(((e,t)=>[fromCharCode(t),"\\u"+t.toString(16).toUpperCase().padStart(4,"0")]))),"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"','"""':'""\\"',"\\":"\\\\","":"\\u007F"}),{test:NEED_BASIC}=theRegExp(/[\x00-\x08\x0A-\x1F'\x7F]/),BY_ESCAPE=/[^\x00-\x08\x0A-\x1F"\\\x7F]+|./gs,{test:NEED_ESCAPE}=theRegExp(/^[\x00-\x08\x0A-\x1F"\\\x7F]/),singlelineString=e=>{if(NEED_BASIC(e)){const t=e.match(BY_ESCAPE);let r=t.length;do{NEED_ESCAPE(t[--r])&&(t[r]=ESCAPED[t[r]])}while(r);return`"${t.join("")}"`}return`'${e}'`},singlelineBasicString=e=>{if(e){const t=e.match(BY_ESCAPE);let r=t.length;do{NEED_ESCAPE(t[--r])&&(t[r]=ESCAPED[t[r]])}while(r);return`"${t.join("")}"`}return'""'},{test:NEED_MULTILINE_BASIC}=theRegExp(/[\x00-\x08\x0A-\x1F\x7F]|'''/),{test:multilineNeedBasic}=theRegExp(/[\x00-\x08\x0B-\x1F\x7F]|'''/),{test:REAL_MULTILINE_ESCAPE}=theRegExp(/[\x00-\x08\x0A-\x1F\\\x7F]|"""/),BY_MULTILINE_ESCAPE=/[^\x00-\x08\x0A-\x1F"\\\x7F]+|"""|./gs,{test:NEED_MULTILINE_ESCAPE}=theRegExp(/^(?:[\x00-\x08\x0A-\x1F\\\x7F]|""")/),escape_multiline=(e,t)=>{const r=e[t];if(REAL_MULTILINE_ESCAPE(r)){const n=r.match(BY_MULTILINE_ESCAPE);let i=n.length;do{NEED_MULTILINE_ESCAPE(n[--i])&&(n[i]=ESCAPED[n[i]])}while(i);e[t]=n.join("")}},Lines=e=>1===(e=["",...e]).length?["",""]:e,multilineString=e=>{const t=e.length-1;let r=t;do{if(NEED_MULTILINE_BASIC(e[r]))break}while(--r);if(r)for(r=t,escape_multiline(e,r),e[r]+=e[0]='"""';--r;)escape_multiline(e,r);else e[t]+=e[0]="'''";return e},multilineBasicString=e=>{let t=e.length-1;for(escape_multiline(e,t),e[t]+=e[0]='"""';--t;)escape_multiline(e,t);return e},multilineLiteralString=e=>(e[e.length-1]+=e[0]="'''",e),Float64Array$1=Float64Array,Uint8Array$1=Uint8Array,_Infinity=-1/0,{test:INTEGER_LIKE}=theRegExp(/^-?\d+$/),ensureFloat=e=>INTEGER_LIKE(e)?e+".0":e,float64Array=new Float64Array$1([NaN]),uint8Array=new Uint8Array$1(float64Array.buffer),NaN_7=uint8Array[7],float=NaN_7===new Uint8Array$1(new Float64Array$1([NaN]).buffer)[7]?e=>e?1/0===e?"inf":e===-1/0?"-inf":ensureFloat(""+e):e==e?is(e,0)?"0.0":"-0.0":"nan":e=>e?1/0===e?"inf":e===-1/0?"-inf":ensureFloat(""+e):e==e?is(e,0)?"0.0":"-0.0":(float64Array[0]=e,uint8Array[7]===NaN_7?"nan":"-nan"),isDate=isPrototypeOf.bind(DATE),{test:BARE}=theRegExp(/^[\w-]+$/),$Key$=e=>BARE(e)?e:singlelineString(e),FIRST=/[^.]+/,literalString=e=>`'${e}'`,$Keys=e=>isAmazing(e)?e.replace(FIRST,literalString):"null"===e?"'null'":e;class TOMLSection extends Array$1{document;constructor(e){return super(),this.document=e,this}[Symbol$1.toPrimitive](){return this.join(this.document.newline)}appendNewline(){this[this.length]=""}set appendLine(e){this[this.length]=e}set appendInline(e){this[this.length-1]+=e}set appendInlineIf(e){e&&(this[this.length-1]+=e)}*assignBlock(e,t,r,n){const{document:i}=this,{newlineUnderHeader:a,newlineUnderSectionButPair:s}=i,l=!!t&&i.newlineUnderPairButDotted,o=t?i.newlineUnderDotted:i.newlineUnderPair;for(const c of n){const n=r[c],u=$Key$(c),_=e+u;if(isArray$1(n)){const{length:e}=n;if(e){let t=n[0];if(isSection(t)){const r=`[[${_}]]`,l=_+".";let o=0,c=t;for(;;){const t=i.appendSection();if(t[0]=r+getCOMMENT(c,commentForThis),a?(t[1]="",yield t.assignBlock(l,"",c,getOwnPropertyNames(c)),s&&2!==t.length&&t.appendNewline()):(yield t.assignBlock(l,"",c,getOwnPropertyNames(c)),s&&t.appendNewline()),++o===e)break;if(c=n[o],!isSection(c))throw TypeError$1("the first table item marked by Section() means the parent array is an array of tables, which can not include other types or table not marked by Section() any more in the rest items")}continue}{let t=1;for(;t!==e;)if(isSection(n[t++]))throw TypeError$1("if an array is not array of tables, it can not include any table that marked by Section()")}}}else if(isSection(n)){const e=i.appendSection();e[0]=`[${_}]${i.preferCommentForThis?getCOMMENT(n,commentForThis)||getComment(r,c):getComment(r,c)||getCOMMENT(n,commentForThis)}`,a?(e[1]="",yield e.assignBlock(_+".","",n,getOwnPropertyNames(n)),s&&2!==e.length&&e.appendNewline()):(yield e.assignBlock(_+".","",n,getOwnPropertyNames(n)),s&&e.appendNewline());continue}const E=t+u;this.appendLine=$Keys(E)+" = ";const h=this.value("",n,!0);h?(--this.length,yield this.assignBlock(_+".",E+".",n,h),l&&this.appendNewline()):(this.appendInlineIf=getComment(r,c),o&&this.appendNewline())}}value(e,t,r){switch(typeof t){case"object":if(null===t){if(this.document.nullDisabled)throw TypeError$1('toml can not stringify "null" type value without truthy options.xNull');this.appendInline="null";break}const n=ofInline(t);if(isArray$1(t)){if(n===undefined$1)this.staticArray(e,t);else{const{$singlelineArray:r=n}=this.document;this.singlelineArray(e,t,r)}break}if(n!==undefined$1){n||this.document.multilineTableDisabled?this.inlineTable(e,t):this.multilineTable(e,t,this.document.multilineTableComma);break}if(isDate(t)){this.appendInline=t.toISOString().replace("T",this.document.T).replace("Z",this.document.Z);break}if(_literal in t){const e=t[_literal];if("string"==typeof e)this.appendInline=e;else{if(!isArray$1(e))throw TypeError$1("literal value is broken");{const{length:t}=e;if(!t)throw TypeError$1("literal value is broken");{this.appendInline=e[0];let r=1;for(;r!==t;)this.appendLine=e[r++]}}}break}if(isString(t))throw TypeError$1("TOML.stringify refuse to handle [object String]");if(isNumber(t))throw TypeError$1("TOML.stringify refuse to handle [object Number]");if(isBigInt(t))throw TypeError$1("TOML.stringify refuse to handle [object BigInt]");if(isBoolean(t))throw TypeError$1("TOML.stringify refuse to handle [object Boolean]");if(r){const e=getOwnPropertyNames(t);if(e.length)return e;this.appendInline="{ }"}else this.inlineTable(e,t);break;case"bigint":this.appendInline=""+t;break;case"number":this.appendInline=this.document.asInteger(t)?is(t,-0)?"-0":""+t:float(t);break;case"string":this.appendInline=singlelineString(t);break;case"boolean":this.appendInline=t?"true":"false";break;default:throw TypeError$1(`toml can not stringify "${typeof t}" type value`)}return null}singlelineArray(e,t,r){const{length:n}=t;if(n){this.appendInline=2&r?"[ ":"[",this.value(e,t[0],!1);let i=1;for(;i!==n;)this.appendInline=", ",this.value(e,t[i++],!1);this.appendInline=2&r?" ]":"]"}else this.appendInline=1&r?"[ ]":"[]"}staticArray(e,t){this.appendInline="[";const r=e+this.document.indent,{length:n}=t;let i=0;for(;i!==n;)this.appendLine=r,this.value(r,t[i++],!1),this.appendInline=",";this.appendLine=e+"]"}inlineTable(e,t){const r=getOwnPropertyNames(t);r.length?(this.appendInline="{ ",this.assignInline(e,t,"",r),this[this.length-1]=this[this.length-1].slice(0,-2)+" }"):this.appendInline="{ }"}multilineTable(e,t,r){this.appendInline="{",this.assignMultiline(e,t,"",getOwnPropertyNames(t),r),this.appendLine=e+"}"}assignInline(e,t,r,n){for(const i of n){const n=t[i],a=r+$Key$(i),s=this.appendInline=$Keys(a)+" = ",l=this.value(e,n,!0);l?(this[this.length-1]=this[this.length-1].slice(0,-s.length),this.assignInline(e,n,a+".",l)):this.appendInline=", "}}assignMultiline(e,t,r,n,i){const a=e+this.document.indent;for(const s of n){const n=t[s],l=r+$Key$(s);this.appendLine=a+$Keys(l)+" = ";const o=this.value(a,n,!0);o?(--this.length,this.assignMultiline(e,n,l+".",o,i)):i?this.appendInline=","+getComment(t,s):this.appendInlineIf=getComment(t,s)}}}const name2code=Null$1({document:0,section:1,header:2,pairs:3,pair:4}),{test:IS_INDENT}=theRegExp(/^[\t ]*$/),return_false=()=>!1;class TOMLDocument extends Array$1{get["constructor"](){return Array$1}0=new TOMLSection(this);asInteger=return_false;newline="";newlineUnderSection=!0;newlineUnderSectionButPair=!0;newlineUnderHeader=!0;newlineUnderPair=!1;newlineUnderPairButDotted=!1;newlineUnderDotted=!1;indent="\t";T="T";Z="Z";nullDisabled=!0;multilineTableDisabled=!0;multilineTableComma;preferCommentForThis=!1;$singlelineArray;constructor(e){if(super(),null==e)return this;const{integer:t}=e;if(void 0===t);else if(t===MAX_SAFE_INTEGER)this.asInteger=isSafeInteger;else{if("number"!=typeof t)throw TypeError$1("TOML.stringify(,{integer}) can only be number");{if(!isSafeInteger(t))throw RangeError$1("TOML.stringify(,{integer}) can only be a safe integer");const e=t>=0?t:-t-1,r=t>=0?-t:t;this.asInteger=t=>isSafeInteger(t)&&r<=t&&t<=e}}const{newline:r}=e;if(void 0===r);else{if("\n"!==r&&"\r\n"!==r)throw"string"==typeof r?SyntaxError$1("TOML.stringify(,{newline}) can only be valid TOML newline"):TypeError$1("TOML.stringify(,{newline}) can only be string");this.newline=r}const{preferCommentFor:n}=e;if(void 0===n);else{if("this"!==n&&"key"!==n)throw TypeError$1("TOML.stringify(,{preferCommentFor) can only be 'key' or 'this'");this.preferCommentForThis="this"===n}const{[e.newlineAround||"header"]:i=name2code.header}=name2code;this.newlineUnderSection=i>0,this.newlineUnderSectionButPair=1===i||2===i,this.newlineUnderHeader=i>1,this.newlineUnderPair=i>2,this.newlineUnderPairButDotted=3===i,this.newlineUnderDotted=i>3;const{indent:a}=e;if(void 0===a);else if("string"==typeof a){if(!IS_INDENT(a))throw SyntaxError$1("TOML.stringify(,{indent}) can only include Tab or Space");this.indent=a}else{if("number"!=typeof a)throw TypeError$1(`TOML.stringify(,{indent}) can not be "${typeof a}" type`);if(!isSafeInteger(a))throw RangeError$1(`TOML.stringify(,{indent:${a}}) is out of range`);this.indent=" ".repeat(a)}const{T:s}=e;if(void 0===s);else{if(" "!==s&&"t"!==s&&"T"!==s)throw TypeError$1('TOML.stringify(,{T}) can only be "T" or " " or "t"');this.T=s}const{Z:l}=e;if(void 0===l);else{if("z"!==l&&"Z"!==l)throw TypeError$1('TOML.stringify(,{Z}) can only be "Z" or "z"');this.Z=l}e.xNull&&(this.nullDisabled=!1);const{xBeforeNewlineInMultilineTable:o}=e;if(void 0===o);else{if(""!==o&&","!==o)throw TypeError$1('TOML.stringify(,{xBeforeNewlineInMultilineTable}) can only be "" or ","');this.multilineTableDisabled=!1,this.multilineTableComma=!!o}const c=e.forceInlineArraySpacing;switch(c){case void 0:break;case 0:case 1:case 2:case 3:this.$singlelineArray=c;break;default:throw"number"==typeof c?RangeError$1(`array inline mode must be 0 | 1 | 2 | 3, not including ${c}`):TypeError$1('array inline mode must be "number" type, not including '+(null===c?'"null"':typeof c))}return this}appendSection(){return this[this.length]=new TOMLSection(this)}}const linesFromStringify=new WeakSet$1,beLinesFromStringify=add.bind(linesFromStringify),isLinesFromStringify=has.bind(linesFromStringify),stringify=(e,t)=>{const r=new TOMLDocument(t),n=r[0];if(n[0]="",x(n.assignBlock("","",e,getOwnPropertyNames(e))),r.newlineUnderSectionButPair&&1!==n.length&&n.appendNewline(),r.newlineUnderSection||r[r.length-1].appendNewline(),r.newline)return r.join(r.newline);const i=r.flat();return beLinesFromStringify(i),i},multiline=(()=>{const e=(e,t)=>"string"==typeof e?LiteralObject((multilineNeedBasic(e)?multilineBasicString:multilineLiteralString)(("\n"+e).split("\n")),e):isArray$1(e)?LiteralObject(multilineString(Lines(e)),"string"==typeof t?t:Null$1(null)):multilineTable(e);return e.basic=(e,t)=>"string"==typeof e?LiteralObject(multilineBasicString(("\n"+e).split("\n")),e):LiteralObject(multilineBasicString(Lines(e)),"string"==typeof t?t:Null$1(null)),e.array=multilineArray,freeze(e),e})(),basic=e=>LiteralObject(singlelineBasicString(e),e),literal=(e,...t)=>{if("string"==typeof e){if(1===t.length)return LiteralObject(e.includes("\n")?e.split("\n"):e,t[0])}else{let r=t.length;if(r){const{raw:n}=e;for(e=n[r];r;)t[--r]+=n[r];e=t.join("")+e}else e=e.raw[0]}return LiteralObject(e.includes("\n")?e.split("\n"):e,Null$1(null))},textDecoder=new TextDecoder$1("utf-8",Null$1({fatal:!0,ignoreBOM:!1})),binary2string=e=>{if(isView(e)?e.length!==e.byteLength:!isArrayBuffer(e))throw TypeError$1("only Uint8Array or ArrayBuffer is acceptable");try{return textDecoder.decode(e)}catch{throw Error$1("A TOML doc must be a (ful-scalar) valid UTF-8 file, without any unknown code point.")}},isBinaryLike=e=>"byteLength"in e,{test:includesNonScalar}=theRegExp(/[\uD800-\uDFFF]/u),assertFulScalar=e=>{if(clearRegExp$1(includesNonScalar(e)))throw Error$1("A TOML doc must be a (ful-scalar) valid UTF-8 file, without any uncoupled UCS-4 character code.")};let holding=!1;const parse=(e,t,r,n,i,a)=>{let s,l,o,c,u="";if("object"==typeof e&&e){if(isArray$1(e))throw TypeError$1(isLinesFromStringify(e)?"TOML.parse(array from TOML.stringify(,{newline?}))":"TOML.parse(array)");if(isBinaryLike(e))e=binary2string(e);else{if(u=e.path,"string"!=typeof u)throw TypeError$1("TOML.parse(source.path)");const{data:t,require:r=("function"==typeof require?require:undefined$1)}=e;if(r){const{resolve:n}=r;if(null!=n){const{paths:e}=n;if(null!=e){const t=apply$1(e,n,[""]);if(null!=t){const e=t[0];if(null!=e){const t=e.replace(/node_modules$/,"");if(t&&(u=r("path").resolve(t,u),"string"!=typeof u))throw TypeError$1("TOML.parse(source.require('path').resolve)")}}}}if(t===undefined$1){const t=r("fs").readFileSync(u);if("object"!=typeof t||!t||!isBinaryLike(t))throw TypeError$1("TOML.parse(source.require('fs').readFileSync)");e=binary2string(t)}else if("string"==typeof t)assertFulScalar(e=t);else{if("object"!=typeof t||!t||!isBinaryLike(t))throw TypeError$1("TOML.parse(source.data)");e=binary2string(t)}}else{if(t===undefined$1)throw TypeError$1("TOML.parse(source.data|source.require)");if("string"==typeof t)assertFulScalar(e=t);else{if("object"!=typeof t||!t||!isBinaryLike(t))throw TypeError$1("TOML.parse(source.data)");e=binary2string(t)}}}}else{if("string"!=typeof e)throw TypeError$1("TOML.parse(source)");assertFulScalar(e)}if("object"==typeof r&&r){if(n!==undefined$1||i!==undefined$1)throw TypeError$1("options mode ? args mode");s=r.joiner,n=r.bigint,l=r.keys,i=r.x,a=""}else s=r;if(holding)throw Error$1("parsing during parsing.");holding=!0;try{use(t,s,n,l,i,a),todo(e,u),e&&"\ufeff"===e[0]&&throws(TypeError$1("TOML content (string) should not start with BOM (U+FEFF)"+where(" at "))),o=Root(),c=Process()}finally{done(),KEYS$1=ANY,useWhatToJoinMultilineString=processor=each=null,zeroDatetime=!1,holding=!1,clearRegExp$1()}return c&&c(),o},parse$1=assign$1(((e,t,r,n,i)=>"number"==typeof t?parse(e,t,r,n,i,",,"):parse(e,1,t,r,n,",")),{"1.0":(e,t,r,n)=>parse(e,.1,t,r,n,","),1:(e,t,r,n)=>parse(e,1,t,r,n,","),.5:(e,t,r,n)=>parse(e,.5,t,r,n,","),.4:(e,t,r,n)=>parse(e,.4,t,r,n,","),.3:(e,t,r,n)=>parse(e,.3,t,r,n,","),.2:(e,t,r,n)=>parse(e,.2,t,r,n,","),.1:(e,t,r,n)=>parse(e,.1,t,r,n,",")}),_export=Default({version,parse:parse$1,stringify,Section,inline,multiline,basic,literal,commentFor,commentForThis,OffsetDateTime,LocalDateTime,LocalDate,LocalTime,isInline,isSection,Keys});export{Keys,LocalDate,LocalDateTime,LocalTime,OffsetDateTime,Section,basic,commentFor,commentForThis,_export as default,inline,isInline,isSection,literal,multiline,parse$1 as parse,stringify,version};
//# sourceMappingURL=j-toml.min.js.map