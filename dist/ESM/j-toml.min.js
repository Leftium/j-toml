/*!@preserve@license
 * 模块名称：j-toml
 * 模块功能：龙腾道为汤小明语写的实现。从属于“简计划”。
   　　　　　An implementation of TOML written by LongTengDao. Belong to "Plan J".
 * 模块版本：1.16.0
 * 许可条款：LGPL-3.0
 * 所属作者：龙腾道 <LongTengDao@LongTengDao.com> (www.LongTengDao.com)
 * 问题反馈：https://GitHub.com/LongTengDao/j-toml/issues
 * 项目主页：https://GitHub.com/LongTengDao/j-toml/
 */
import{readFileSync}from"fs";const version="1.16.0",Error$1=Error,TypeError$1=TypeError,assign$1=Object.assign,isBuffer="function"==typeof Buffer?Buffer.isBuffer:function(){return!1},undefined$1=void 0,from="function"==typeof Buffer&&Buffer.hasOwnProperty("from")?Buffer.from:void 0,bind=Function.prototype.bind,test=RegExp.prototype.test,exec=RegExp.prototype.exec,SyntaxError$1=SyntaxError,RegExp$1=RegExp,freeze=Object.freeze,Reflect_apply=Reflect.apply,Proxy$1=Proxy,create$1=Object.create,NULL=Object.seal?Object.preventExtensions(Object.create(null)):null,toStringTag="undefined"==typeof Symbol?void 0:Symbol.toStringTag,Object_defineProperty=Object.defineProperty,isArray$1=Array.isArray,Infinity=1/0,fromCharCode=String.fromCharCode,Array$1=Array,hasOwnProperty=Object.prototype.hasOwnProperty,propertyIsEnumerable=Object.prototype.propertyIsEnumerable;var isEnum=propertyIsEnumerable.call.bind(propertyIsEnumerable),hasOwn=function(){return hasOwnProperty.bind?hasOwnProperty.call.bind(hasOwnProperty):function(e,t){return hasOwnProperty.call(e,t)}}(),create=Object.create;const Default=function(e,t){if(t||(t=e,e=create$1(NULL)),assign$1)assign$1(e,t);else for(var r in t)hasOwn(t,r)&&(e[r]=t[r]);if(e.default=e,toStringTag){var n=create$1(NULL);n.value="Module",Object_defineProperty(e,toStringTag,n)}return"function"==typeof e&&e.prototype&&freeze(e.prototype),freeze(e)};var Test=bind?bind.bind(test):function(e){return function(t){return test.call(e,t)}},Exec=bind?bind.bind(exec):function(e){return function(t){return exec.call(e,t)}};function theRegExp(e){var t=e.test=Test(e),r=e.exec=Exec(e),n=t.source=r.source=e.source;return t.unicode=r.unicode=e.unicode,t.ignoreCase=r.ignoreCase=e.ignoreCase,t.multiline=r.multiline=n.indexOf("^")<0&&n.indexOf("$")<0?null:e.multiline,t.dotAll=r.dotAll=n.indexOf(".")<0?null:e.dotAll,e}var NT=/[\n\t]+/g,ESCAPE=/\\./g;function graveAccentReplacer(e){return"\\`"===e?"`":e}var includes="".includes?function(e,t){return e.includes(t)}:function(e,t){return e.indexOf(t)>-1};function RE(e){for(var t=this.U,r=this.I,n=this.M,i=this.S,a=e.raw,s=a[0].replace(NT,""),l=1,o=arguments.length;l!==o;){var c=arguments[l];if("string"==typeof c)s+=c;else{var _=c.source;if("string"!=typeof _)throw TypeError$1("source");if(c.unicode===t)throw SyntaxError$1("unicode");if(c.ignoreCase===r)throw SyntaxError$1("ignoreCase");if(c.multiline===n&&(includes(_,"^")||includes(_,"$")))throw SyntaxError$1("multiline");if(c.dotAll===i&&includes(_,"."))throw SyntaxError$1("dotAll");s+=_}s+=a[l++].replace(NT,"")}var u=RegExp$1(t?s=s.replace(ESCAPE,graveAccentReplacer):s,this.flags),E=u.test=Test(u),T=u.exec=Exec(u);return E.source=T.source=s,E.unicode=T.unicode=t,E.ignoreCase=T.ignoreCase=r,E.multiline=T.multiline=includes(s,"^")||includes(s,"$")?n:null,E.dotAll=T.dotAll=includes(s,".")?i:null,u}var RE_bind=bind&&bind.bind(RE);function Context(e){return{U:!includes(e,"u"),I:!includes(e,"i"),M:!includes(e,"m"),S:!includes(e,"s"),flags:e}}var CONTEXT=Context(""),newRegExp=Proxy$1?new Proxy$1(RE,{apply:function(e,t,r){return Reflect_apply(e,CONTEXT,r)},get:function(e,t){return RE_bind(Context(t))},defineProperty:function(){return!1},preventExtensions:function(){return!1}}):function(){RE.apply=RE.apply;for(var e=function(){return RE.apply(CONTEXT,arguments)},t=63;t--;)!function(t){e[t.flags]=function(){return RE.apply(t,arguments)}}(Context((32&t?"":"g")+(16&t?"":"i")+(8&t?"":"m")+(4&t?"":"s")+(2&t?"":"u")+(1&t?"":"y")));return freeze?freeze(e):e}(),clearRegExp="$_"in RegExp$1?function(){var e=/^/;return e.test=e.test,function(t){return e.test(""),t}}():function(e){return e};const RegExp_prototype=RegExp.prototype;var NON_SCALAR="unicode"in RegExp_prototype?RegExp$1("[\\uD800-\\uDFFF]","u"):/[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;const NONE=[];let sourcePath="",sourceLines=NONE,lastLineIndex=-1,lineIndex=-1;const throws=e=>{throw e},could=()=>{if(sourceLines!==NONE)throw Error$1("Internal error: parsing during parsing.")},EOL=/\r?\n/,todo=(e,t)=>{if("string"!=typeof t)throw TypeError$1("TOML.parse(,,,,sourcePath)");sourcePath=t,sourceLines=e.split(EOL),lastLineIndex=sourceLines.length-1,lineIndex=-1},next=()=>sourceLines[++lineIndex],rest=()=>lineIndex!==lastLineIndex,mark=e=>({type:e,lineIndex}),must=e=>(lineIndex===lastLineIndex&&throws(SyntaxError$1(`${e.type} is not close until the end of the file`+where(", which started from ",e.lineIndex))),sourceLines[++lineIndex]),where=(e,t=lineIndex)=>sourceLines===NONE?"":sourcePath?`\n    at (${sourcePath}:${t+1}:1)`:`${e}line ${t+1}: ${sourceLines[t]}`,done=()=>{sourcePath="",sourceLines=NONE},RangeError$1=RangeError,WeakMap$1=WeakMap,get=WeakMap.prototype.get,set=WeakMap.prototype.set,isSafeInteger=Number.isSafeInteger,ownKeys=Reflect.ownKeys,MAX_SAFE_INTEGER=Number.MAX_SAFE_INTEGER,MIN_SAFE_INTEGER=Number.MIN_SAFE_INTEGER,WeakSet$1=WeakSet,set_has=WeakSet.prototype.has,set_add=WeakSet.prototype.add,del=WeakSet.prototype.delete,Object_keys=Object.keys,getOwnPropertySymbols=Object.getOwnPropertySymbols,Null$1=function(){var e=Object.assign||function(e,t){var r,n,i;for(r=Object_keys(t),n=0;n<r.length;++n)e[i=r[n]]=t[i];if(getOwnPropertySymbols)for(r=getOwnPropertySymbols(t),n=0;n<r.length;++n)isEnum(t,i=r[n])&&([i]=t[i]);return e};function t(e){return delete e.prototype.constructor,freeze(e.prototype),e}var r=function(r){return void 0===r?this:"function"==typeof r?t(r):e(create(NULL),r)};return delete r.name,r.prototype=null,freeze(r),r}(),is=Object.is,fromEntries=Object.fromEntries,Reflect_construct=Reflect.construct,Reflect_defineProperty=Reflect.defineProperty,Reflect_deleteProperty=Reflect.deleteProperty,Keeper=()=>[],hasOwnProperty_call=hasOwnProperty.call.bind(hasOwnProperty),newWeakMap=()=>{const e=new WeakMap$1;return e.has=e.has,e.get=e.get,e.set=e.set,e},target2keeper=newWeakMap(),proxy2target=newWeakMap(),target2proxy=newWeakMap(),handlers=assign$1(create$1(NULL),{defineProperty:(e,t,r)=>{if(hasOwnProperty_call(e,t))return Reflect_defineProperty(e,t,assign$1(create$1(NULL),r));if(Reflect_defineProperty(e,t,assign$1(create$1(NULL),r))){const r=target2keeper.get(e);return r[r.length]=t,!0}return!1},deleteProperty:(e,t)=>{if(Reflect_deleteProperty(e,t)){const r=target2keeper.get(e),n=r.indexOf(t);return n<0||--r.copyWithin(n,n+1).length,!0}return!1},ownKeys:e=>target2keeper.get(e),construct:(e,t,r)=>orderify(Reflect_construct(e,t,r)),apply:(e,t,r)=>orderify(Reflect_apply(e,t,r))}),newProxy=(e,t)=>{target2keeper.set(e,t);const r=new Proxy$1(e,handlers);return proxy2target.set(r,e),r},orderify=e=>{if(proxy2target.has(e))return e;let t=target2proxy.get(e);return t||(t=newProxy(e,assign$1([],ownKeys(e))),target2proxy.set(e,t),t)},Null=function(){function e(){throw TypeError$1("Super constructor Null cannot be invoked with 'new'")}function t(){throw TypeError$1("Super constructor Null cannot be invoked without 'new'")}const r=e=>(delete e.prototype.constructor,freeze(e.prototype),e);function n(i){return new.target?new.target===n?e():newProxy(this,[]):"function"==typeof i?r(i):t()}return n.prototype=null,Object_defineProperty(n,"name",assign$1(create$1(NULL),{value:"",configurable:!1})),freeze(n),n}(),map_has=WeakMap.prototype.has,INLINES=new WeakMap$1,isInline=map_has.bind(INLINES),ofInline=get.bind(INLINES),beInline=set.bind(INLINES),inline=e=>(beInline(e,!0),e),multilineTable=e=>(beInline(e,!1),e),SECTIONS=new WeakSet$1,isSection=set_has.bind(SECTIONS),beSection=set_add.bind(SECTIONS),Section=e=>{if(isArray$1(e))throw TypeError$1("array can not be section, maybe you want to use it on the tables in it");return beSection(e),e},INLINE=!0,tables=new WeakSet$1,tables_add=set_add.bind(tables),isTable=set_has.bind(tables),implicitTables=new WeakSet$1,implicitTables_add=set_add.bind(implicitTables),implicitTables_del=del.bind(implicitTables),directlyIfNot=e=>!!implicitTables_del(e)&&(beSection(e),!0),DIRECTLY=!0,IMPLICITLY=!1,pairs=new WeakSet$1,pairs_add=set_add.bind(pairs),fromPair=set_has.bind(pairs),PAIR=!0,PlainTable=Null$1(class extends Null$1{constructor(e,t){return super(),tables_add(this),e?t?beInline(this,!0):beSection(this):(t?pairs_add:implicitTables_add)(this),this}}),OrderedTable=Null$1(class extends Null{constructor(e,t){return super(),tables_add(this),e?t?beInline(this,!0):beSection(this):(t?pairs_add:implicitTables_add)(this),this}}),Whitespace=/[ \t]/,PRE_WHITESPACE=(()=>newRegExp`
	^${Whitespace}+`)(),VALUE_REST_exec=(()=>newRegExp.s`
	^
	(
		(?:\d\d\d\d-\d\d-\d\d \d)?
		[\w\-+.:]+
	)
	${Whitespace}*
	(.*)
	$`.exec)(),LITERAL_STRING_exec=(()=>newRegExp.s`
	^
	'([^']*)'
	${Whitespace}*
	(.*)`.exec)(),MULTI_LINE_LITERAL_STRING_0_1_2=(()=>newRegExp.s`
	^
	(.*?)
	'''('{0,2})
	${Whitespace}*
	(.*)`.exec)(),MULTI_LINE_LITERAL_STRING_0=(()=>newRegExp.s`
	^
	(.*?)
	'''()
	${Whitespace}*
	(.*)`.exec)();let __MULTI_LINE_LITERAL_STRING_exec;const SYM_WHITESPACE=(()=>newRegExp.s`
	^
	.
	${Whitespace}*`)(),Tag=/[^\x00-\x1F"#'()<>[\\\]`{}\x7F]+/,KEY_VALUE_PAIR_exec=(()=>newRegExp.s`
	^
	${Whitespace}*
	=
	${Whitespace}*
	(?:
		<(${Tag})>
		${Whitespace}*
	)?
	(.*)
	$`.exec)(),_VALUE_PAIR_exec=(()=>newRegExp.s`
	^
	<(${Tag})>
	${Whitespace}*
	(.*)
	$`.exec)(),TAG_REST_exec=(()=>newRegExp.s`
	^
	<(${Tag})>
	${Whitespace}*
	(.*)
	$`.exec)(),MULTI_LINE_BASIC_STRING=/(?<=^(?:[^\\"]+|\\.|""?(?!")))/s,MULTI_LINE_BASIC_STRING_exec_0=e=>{let t=0;for(let r=e.search(MULTI_LINE_BASIC_STRING);r>0;)r=e.slice(t+=r).search(MULTI_LINE_BASIC_STRING);return e.slice(0,t)},ESCAPED_EXCLUDE_CONTROL_CHARACTER_TAB______=/[^\\\x00-\x08\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|[\t ]*\n[\t\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g,ESCAPED_EXCLUDE_CONTROL_CHARACTER__________=/[^\\\x00-\x09\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]| *\n[\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g,ESCAPED_EXCLUDE_CONTROL_CHARACTER_DEL______=/[^\\\x00-\x09\x0B-\x1F]+|\\(?:[btnfr"\\]|\n[\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g,ESCAPED_EXCLUDE_CONTROL_CHARACTER_DEL_SLASH=/[^\\\x00-\x09\x0B-\x1F]+|\\(?:[btnfr"\\/]|\n[\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g;let __ESCAPED_EXCLUDE_CONTROL_CHARACTER;const ESCAPED_EXCLUDE_CONTROL_CHARACTER_test=e=>!e.replace(__ESCAPED_EXCLUDE_CONTROL_CHARACTER,""),BASIC_STRING_TAB______=/(?<=^(?:[^\\"\x00-\x08\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})))/,BASIC_STRING__________=/(?<=^(?:[^\\"\x00-\x09\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})))/,BASIC_STRING_DEL______=/(?<=^(?:[^\\"\x00-\x09\x0B-\x1F]+|\\(?:[btnfr"\\]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})))/,BASIC_STRING_DEL_SLASH=/(?<=^(?:[^\\"\x00-\x09\x0B-\x1F]+|\\(?:[btnfr"\\/]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})))/;let __BASIC_STRING;const BASIC_STRING_exec_1=e=>{let t=1;for(let r=e.slice(1).search(__BASIC_STRING);r>0;)r=e.slice(t+=r).search(__BASIC_STRING);return t!==e.length&&'"'===e[t]||throws(SyntaxError$1("Bad basic string"+where(" at "))),e.slice(1,t)},IS_DOT_KEY=(()=>theRegExp(/^[ \t]*\./).test)(),DOT_KEY=/^[ \t]*\.[ \t]*/,BARE_KEY_STRICT=(()=>theRegExp(/^[\w-]+/).exec)(),BARE_KEY_FREE=(()=>theRegExp(/^[^ \t#=[\]'".]+(?:[ \t]+[^ \t#=[\]'".]+)*/).exec)();let __BARE_KEY_exec;const LITERAL_KEY____=(()=>theRegExp(/^'[^'\x00-\x08\x0B-\x1F\x7F]*'/).exec)(),LITERAL_KEY_DEL=(()=>theRegExp(/^'[^'\x00-\x08\x0B-\x1F]*'/).exec)();let __LITERAL_KEY_exec,supportArrayOfTables;const TABLE_DEFINITION_exec_groups=(e,t)=>{const r="["===e[1];r?(supportArrayOfTables||throws(SyntaxError$1("Array of Tables is not allowed before TOML v0.2"+where(", which at "))),e=e.slice(2)):e=e.slice(1),e=e.replace(PRE_WHITESPACE,"");const{leadingKeys:n,finalKey:i}=({lineRest:e}=t(e));let a;return(e=e.replace(PRE_WHITESPACE,""))&&"]"===e[0]||throws(SyntaxError$1("Table header is not closed"+where(", which is found at "))),(e.length>1?"]"===e[1]===r:!r)||throws(SyntaxError$1("Square brackets of Table definition statement not match"+where(" at "))),(e=e.slice(r?2:1).replace(PRE_WHITESPACE,""))&&"<"===e[0]?({1:a,2:e}=TAG_REST_exec(e)??throws(SyntaxError$1("Bad tag"+where(" at ")))):a="",{leadingKeys:n,finalKey:i,asArrayItem:r,tag:a,lineRest:e}},KEY_VALUE_PAIR_exec_groups=({leadingKeys:e,finalKey:t,lineRest:r})=>{const{1:n=""}=({2:r}=KEY_VALUE_PAIR_exec(r)??throws(SyntaxError$1("Keys must equal something"+where(", but missing at "))));return n||r&&"#"!==r[0]||throws(SyntaxError$1("Value can not be missing after euqal sign"+where(", which is found at "))),{leadingKeys:e,finalKey:t,tag:n,lineRest:r}},CONTROL_CHARACTER_EXCLUDE_TAB____=(()=>theRegExp(/[\x00-\x08\x0B-\x1F\x7F]/).test)(),CONTROL_CHARACTER_EXCLUDE_TAB_DEL=(()=>theRegExp(/[\x00-\x08\x0B-\x1F]/).test)();let __CONTROL_CHARACTER_EXCLUDE_test;const switchRegExp=e=>{switch(e){case 1:__MULTI_LINE_LITERAL_STRING_exec=MULTI_LINE_LITERAL_STRING_0_1_2,__LITERAL_KEY_exec=LITERAL_KEY____,__CONTROL_CHARACTER_EXCLUDE_test=CONTROL_CHARACTER_EXCLUDE_TAB____,__ESCAPED_EXCLUDE_CONTROL_CHARACTER=ESCAPED_EXCLUDE_CONTROL_CHARACTER_TAB______,__BASIC_STRING=BASIC_STRING_TAB______,__BARE_KEY_exec=BARE_KEY_STRICT,supportArrayOfTables=!0;break;case.5:__MULTI_LINE_LITERAL_STRING_exec=MULTI_LINE_LITERAL_STRING_0,__LITERAL_KEY_exec=LITERAL_KEY____,__CONTROL_CHARACTER_EXCLUDE_test=CONTROL_CHARACTER_EXCLUDE_TAB____,__ESCAPED_EXCLUDE_CONTROL_CHARACTER=ESCAPED_EXCLUDE_CONTROL_CHARACTER__________,__BASIC_STRING=BASIC_STRING__________,__BARE_KEY_exec=BARE_KEY_STRICT,supportArrayOfTables=!0;break;case.4:__MULTI_LINE_LITERAL_STRING_exec=MULTI_LINE_LITERAL_STRING_0,__LITERAL_KEY_exec=LITERAL_KEY_DEL,__CONTROL_CHARACTER_EXCLUDE_test=CONTROL_CHARACTER_EXCLUDE_TAB_DEL,__ESCAPED_EXCLUDE_CONTROL_CHARACTER=ESCAPED_EXCLUDE_CONTROL_CHARACTER_DEL______,__BASIC_STRING=BASIC_STRING_DEL______,__BARE_KEY_exec=BARE_KEY_STRICT,supportArrayOfTables=!0;break;default:__MULTI_LINE_LITERAL_STRING_exec=MULTI_LINE_LITERAL_STRING_0,__LITERAL_KEY_exec=LITERAL_KEY_DEL,__CONTROL_CHARACTER_EXCLUDE_test=CONTROL_CHARACTER_EXCLUDE_TAB_DEL,__ESCAPED_EXCLUDE_CONTROL_CHARACTER=ESCAPED_EXCLUDE_CONTROL_CHARACTER_DEL_SLASH,__BASIC_STRING=BASIC_STRING_DEL_SLASH,__BARE_KEY_exec=BARE_KEY_FREE,supportArrayOfTables=!1}},THROW_WHILE_MEETING_MULTI={[Symbol.toPrimitive](){throws(Error$1("TOML.parse(,,multilineStringJoiner) must be passed, while the source including multi-line string"+where(", which is found at ")))}};let endsWithQuote,zeroDatetime,inlineTable,moreDatetime,disallowEmptyKey,sError,sFloat,Table,allowLonger,enableNull,allowInlineTableMultilineAndTrailingCommaEvenNoComma,preserveComment,useWhatToJoinMultilineString="",usingBigInt=!0,IntegerMin=0,IntegerMax=0;const arrayTypes=new WeakMap$1,arrayTypes_get=get.bind(arrayTypes),arrayTypes_set=set.bind(arrayTypes),As=()=>{const e=t=>{const r=arrayTypes_get(t);return r?r===e||throws(TypeError$1("Types in Array must be same"+where(". Check "))):arrayTypes_set(t,e),t};return e},AS_TYPED={asNulls:As(),asStrings:As(),asTables:As(),asArrays:As(),asBooleans:As(),asFloats:As(),asIntegers:As(),asOffsetDateTimes:As(),asLocalDateTimes:As(),asLocalDates:As(),asLocalTimes:As()},asMixed=e=>e;let asNulls,asStrings,asTables,asArrays,asBooleans,asFloats,asIntegers,asOffsetDateTimes,asLocalDateTimes,asLocalDates,asLocalTimes,processor=null,collection=[],collection_length=0;const collect_on=(e,t,r,n)=>{const i=create$1(NULL);i.tag=e,r&&(i.table=r,i.key=n),t&&(i.array=t,i.index=t.length),collection[collection_length++]=i},collect_off=()=>{throws(SyntaxError$1("xOptions.tag is not enabled, but found tag syntax"+where(" at ")))};let collect=collect_off;const process=()=>{if(collection_length){done();const e=processor,t=collection;for(processor=null,collection=[];collection_length--;)e(t[collection_length]),t.length=collection_length}},clear=()=>{processor=null,collection.length=collection_length=0,zeroDatetime=!1},use=(e,t,r,n)=>{let i;switch(e){case 1:i=endsWithQuote=moreDatetime=sFloat=inlineTable=!0,zeroDatetime=disallowEmptyKey=!1;break;case.5:moreDatetime=sFloat=inlineTable=!0,i=endsWithQuote=zeroDatetime=disallowEmptyKey=!1;break;case.4:disallowEmptyKey=inlineTable=!0,i=endsWithQuote=zeroDatetime=moreDatetime=sFloat=!1;break;case.3:disallowEmptyKey=!0,i=endsWithQuote=zeroDatetime=moreDatetime=sFloat=inlineTable=!1;break;case.2:case.1:zeroDatetime=disallowEmptyKey=!0,i=endsWithQuote=moreDatetime=sFloat=inlineTable=!1;break;default:throw RangeError$1("TOML.parse(,specificationVersion)")}if(switchRegExp(e),"string"==typeof t)useWhatToJoinMultilineString=t;else{if(void 0!==t)throw TypeError$1("TOML.parse(,,multilineStringJoiner)");useWhatToJoinMultilineString=THROW_WHILE_MEETING_MULTI}if(void 0===r||!0===r)usingBigInt=!0;else if(!1===r)usingBigInt=!1;else{if("number"!=typeof r)throw TypeError$1("TOML.parse(,,,useBigInt)");if(!isSafeInteger(r))throw RangeError$1("TOML.parse(,,,useBigInt)");if(usingBigInt=null,r>=0?IntegerMin=-(IntegerMax=r):IntegerMax=-(IntegerMin=r)-1,IntegerMin<MIN_SAFE_INTEGER||MAX_SAFE_INTEGER<IntegerMax)throw RangeError$1("TOML.parse(,,,useBigInt)")}if(null==n||!1===n)Table=PlainTable,sError=allowLonger=enableNull=allowInlineTableMultilineAndTrailingCommaEvenNoComma=!1,collect=collect_off;else if(!0===n)Table=OrderedTable,allowLonger=sError=enableNull=allowInlineTableMultilineAndTrailingCommaEvenNoComma=!0,collect=collect_off;else if("function"==typeof n){if(Table=OrderedTable,allowLonger=sError=enableNull=allowInlineTableMultilineAndTrailingCommaEvenNoComma=!0,!i)throw TypeError$1("TOML.parse(,,,,tag) needs at least TOML 1.0 to support mixed type array");processor=n,collect=collect_on}else{const{order:e,longer:t,exact:r,null:a,multi:s,comment:l,tag:o,...c}=n;if(ownKeys(c).length)throw TypeError$1("TOML.parse(,,,,xOptions)");if(Table=e?OrderedTable:PlainTable,allowLonger=!!t,sError=!!r,enableNull=!!a,allowInlineTableMultilineAndTrailingCommaEvenNoComma=!!s,preserveComment=!!l,o){if("function"!=typeof o)throw TypeError$1("TOML.parse(,,,,xOptions.tag)");if(!i)throw TypeError$1("TOML.parse(,,,,xOptions) xOptions.tag needs at least TOML 1.0 to support mixed type array");processor=o,collect=collect_on}else collect=collect_off}i?asNulls=asStrings=asTables=asArrays=asBooleans=asFloats=asIntegers=asOffsetDateTimes=asLocalDateTimes=asLocalDates=asLocalTimes=asMixed:({asNulls,asStrings,asTables,asArrays,asBooleans,asFloats,asIntegers,asOffsetDateTimes,asLocalDateTimes,asLocalDates,asLocalTimes}=AS_TYPED)},NaN=0/0,previous=Symbol("previous"),x=e=>{let t=e,r=t.next();if(!r.done)for(r.value[previous]=t,r=(t=r.value).next();;)if(r.done){if(t===e)break;t=t[previous],r=t.next(r.value)}else r.value[previous]=t,r=(t=r.value).next();return r.value},arrays=new WeakSet$1,arrays_add=set_add.bind(arrays),isArray=set_has.bind(arrays),OF_TABLES=!1,STATICALLY=!0,staticalArrays=new WeakSet$1,staticalArrays_add=set_add.bind(staticalArrays),isStatic=set_has.bind(staticalArrays),newArray=e=>{const t=[];return arrays_add(t),e&&staticalArrays_add(t),t},TOMLDatetime=Date,parse$2=Date.parse,preventExtensions=Object.preventExtensions,fpc=e=>(freeze(freeze(e).prototype),e),_29_=/(?:0[1-9]|1\d|2\d)/,_30_=/(?:0[1-9]|[12]\d|30)/,_31_=/(?:0[1-9]|[12]\d|3[01])/,_23_=/(?:[01]\d|2[0-3])/,_59_=/[0-5]\d/,YMD=(()=>newRegExp`
	\d\d\d\d-
	(?:
		0
		(?:
			[13578]-${_31_}
			|
			[469]-${_30_}
			|
			2-${_29_}
		)
		|
		1
		(?:
			[02]-${_31_}
			|
			1-${_30_}
		)
	)
`)(),HMS=(()=>newRegExp`
	${_23_}:${_59_}:${_59_}
`)(),OFFSET$=/(?:Z|[+-]\d\d:\d\d)$/,Z_exec=(()=>theRegExp(/(([+-])\d\d):(\d\d)$/).exec)(),OFFSET_DATETIME_exec=(()=>newRegExp`
	^
	${YMD}
	[T ]
	${HMS}
	(?:\.\d{1,3}(\d*?)0*)?
	(?:Z|[+-]${_23_}:${_59_})
	$`.exec)(),OFFSET_DATETIME_ZERO_exec=(()=>newRegExp`
	^
	${YMD}
	[T ]
	${HMS}
	()
	Z
	$`.exec)(),IS_LOCAL_DATETIME=(()=>newRegExp`
	^
	${YMD}
	[T ]
	${HMS}
	(?:\.\d+)?
	$`.test)(),IS_LOCAL_DATE=(()=>newRegExp`
	^
	${YMD}
	$`.test)(),IS_LOCAL_TIME=(()=>newRegExp`
	^
	${HMS}
	(?:\.\d+)?
	$`.test)(),DOT_ZERO=/\.?0+$/,DELIMITER_DOT=/[-T:.]/g,ZERO=/(?<=\.\d*)0+$/,Datetime=(()=>{const e=function(){return this},t=Null$1(null);{const e=Null$1(null);for(const r of ownKeys(TOMLDatetime.prototype))"constructor"===r||"toJSON"===r||(t[r]=e)}return e.prototype=preventExtensions(create$1(TOMLDatetime.prototype,t)),freeze(e)})(),Value=e=>e.replace(ZERO,"").replace(DELIMITER_DOT,""),leap=e=>"02-29"!==e.slice(5,10)||+e.slice(0,4)%4==0&&"00"!==e.slice(2,4),DATE=new TOMLDatetime(0),OffsetDateTime_ISOString=Symbol("OffsetDateTime_ISOString"),OffsetDateTime_value=Symbol("OffsetDateTime_value"),OffsetDateTime_use=(e,t=0)=>(DATE.setTime(+e[OffsetDateTime_value]+t),DATE),OffsetDateTime_get=(e,t,r)=>+e[OffsetDateTime_ISOString].slice(t,r),OffsetDateTime_set=(e,t,r,n)=>{r&&(e[OffsetDateTime_ISOString]=e[OffsetDateTime_ISOString].slice(0,t)+(""+n).padStart(r-t,"0")+e[OffsetDateTime_ISOString].slice(r));const i=parse$2(e[OffsetDateTime_ISOString]);return e[OffsetDateTime_value]=(""+i).padStart(15,"0")+e[OffsetDateTime_value].slice(15),i},OffsetDateTime=fpc(class extends Datetime{[OffsetDateTime_ISOString];[OffsetDateTime_value];valueOf(){return this[OffsetDateTime_value]}toISOString(){return this[OffsetDateTime_ISOString]}constructor(e){const{1:t}=leap(e)&&(zeroDatetime?OFFSET_DATETIME_ZERO_exec:OFFSET_DATETIME_exec)(e)||throws(SyntaxError$1(`Invalid Offset Date-Time ${e}`+where(" at ")));return super(),this[OffsetDateTime_ISOString]=e.replace(" ","T"),this[OffsetDateTime_value]=(""+parse$2(this[OffsetDateTime_ISOString])).padStart(15,"0")+(t?"."+t:""),this}getUTCFullYear(){return OffsetDateTime_use(this).getUTCFullYear()}getFullYear(){return OffsetDateTime_get(this,0,4)}setFullYear(e){return OffsetDateTime_set(this,0,4,e)}getUTCMonth(){return OffsetDateTime_use(this).getUTCMonth()}getMonth(){return OffsetDateTime_get(this,5,7)-1}setMonth(e){return OffsetDateTime_set(this,5,7,e+1)}getUTCDate(){return OffsetDateTime_use(this).getUTCDate()}getDate(){return OffsetDateTime_get(this,8,10)}setDate(e){return OffsetDateTime_set(this,8,10,e)}getUTCHours(){return OffsetDateTime_use(this).getUTCHours()}getHours(){return OffsetDateTime_get(this,11,13)}setHours(e){return OffsetDateTime_set(this,11,13,e)}getUTCMinutes(){return OffsetDateTime_use(this).getUTCMinutes()}getMinutes(){return OffsetDateTime_get(this,14,16)}setMinutes(e){return OffsetDateTime_set(this,14,16,e)}getUTCSeconds(){return OffsetDateTime_use(this).getUTCSeconds()}getSeconds(){return OffsetDateTime_get(this,17,19)}setSeconds(e){return OffsetDateTime_set(this,17,19,e)}getUTCMilliseconds(){return OffsetDateTime_use(this).getUTCMilliseconds()}getMilliseconds(){return+this[OffsetDateTime_value].slice(12,15)}setMilliseconds(e){return this[OffsetDateTime_ISOString]=this[OffsetDateTime_ISOString].slice(0,19)+(e?("."+(""+e).padStart(3,"0")).replace(DOT_ZERO,""):"")+this[OffsetDateTime_ISOString].slice(this[OffsetDateTime_ISOString].search(OFFSET$)),OffsetDateTime_set(this,0,0,0)}getUTCDay(){return OffsetDateTime_use(this).getUTCDay()}getDay(){return OffsetDateTime_use(this,6e4*this.getTimezoneOffset()).getUTCDay()}getTimezoneOffset(){const e=Z_exec(this[OffsetDateTime_ISOString]);return e?60*+e[1]+ +(e[2]+e[3]):0}setTimezoneOffset(e){let t=OffsetDateTime_use(this,6e4*(e=+e)).toISOString().slice(0,-1);if(e){e>0?t+="+":(t+="-",e=-e);const r=e%60,n=(e-r)/60;this[OffsetDateTime_ISOString]=t+(n>9?n:"0"+n)+(r>9?":"+r:":0"+r)}else this[OffsetDateTime_ISOString]=t+(is(e,0)?"Z":"-00:00")}getTime(){return+this[OffsetDateTime_value].slice(0,15)}setTime(e){e=DATE.setTime(e);const t=Z_exec(this[OffsetDateTime_ISOString]);return DATE.setTime(e+6e4*(t?60*+t[1]+ +(t[2]+t[3]):0)),this[OffsetDateTime_ISOString]=t?DATE.toISOString().slice(0,-1)+t[0]:DATE.toISOString(),this[OffsetDateTime_value]=(""+e).padStart(15,"0"),e}}),LocalDateTime_ISOString=Symbol("LocalDateTime_ISOString"),LocalDateTime_value=Symbol("LocalDateTime_value"),LocalDateTime_get=(e,t,r)=>+e[LocalDateTime_ISOString].slice(t,r),LocalDateTime_set=(e,t,r,n)=>{e[LocalDateTime_value]=Value(e[LocalDateTime_ISOString]=e[LocalDateTime_ISOString].slice(0,t)+(""+n).padStart(r-t,"0")+e[LocalDateTime_ISOString].slice(r))},LocalDateTime=fpc(class extends Datetime{[LocalDateTime_ISOString];[LocalDateTime_value];valueOf(){return this[LocalDateTime_value]}toISOString(){return this[LocalDateTime_ISOString]}constructor(e){return IS_LOCAL_DATETIME(e)&&leap(e)||throws(SyntaxError$1(`Invalid Local Date-Time ${e}`+where(" at "))),super(),this[LocalDateTime_value]=Value(this[LocalDateTime_ISOString]=e.replace(" ","T")),this}getFullYear(){return LocalDateTime_get(this,0,4)}setFullYear(e){return LocalDateTime_set(this,0,4,e)}getMonth(){return LocalDateTime_get(this,5,7)-1}setMonth(e){return LocalDateTime_set(this,5,7,e+1)}getDate(){return LocalDateTime_get(this,8,10)}setDate(e){return LocalDateTime_set(this,8,10,e)}getHours(){return LocalDateTime_get(this,11,13)}setHours(e){return LocalDateTime_set(this,11,13,e)}getMinutes(){return LocalDateTime_get(this,14,16)}setMinutes(e){return LocalDateTime_set(this,14,16,e)}getSeconds(){return LocalDateTime_get(this,17,19)}setSeconds(e){return LocalDateTime_set(this,17,19,e)}getMilliseconds(){return+this[LocalDateTime_value].slice(14,17).padEnd(3,"0")}setMilliseconds(e){this[LocalDateTime_value]=Value(this[LocalDateTime_ISOString]=this[LocalDateTime_ISOString].slice(0,19)+(e?("."+(""+e).padStart(3,"0")).replace(DOT_ZERO,""):""))}}),LocalDate_ISOString=Symbol("LocalDate_ISOString"),LocalDate_value=Symbol("LocalDate_value"),LocalDate_get=(e,t,r)=>+e[LocalDate_ISOString].slice(t,r),LocalDate_set=(e,t,r,n)=>{e[LocalDate_value]=Value(e[LocalDate_ISOString]=e[LocalDate_ISOString].slice(0,t)+(""+n).padStart(r-t,"0")+e[LocalDate_ISOString].slice(r))},LocalDate=fpc(class extends Datetime{[LocalDate_ISOString];[LocalDate_value];valueOf(){return this[LocalDate_value]}toISOString(){return this[LocalDate_ISOString]}constructor(e){return IS_LOCAL_DATE(e)&&leap(e)||throws(SyntaxError$1(`Invalid Local Date ${e}`+where(" at "))),super(),this[LocalDate_value]=Value(this[LocalDate_ISOString]=e),this}getFullYear(){return LocalDate_get(this,0,4)}setFullYear(e){return LocalDate_set(this,0,4,e)}getMonth(){return LocalDate_get(this,5,7)-1}setMonth(e){return LocalDate_set(this,5,7,e+1)}getDate(){return LocalDate_get(this,8,10)}setDate(e){return LocalDate_set(this,8,10,e)}}),LocalTime_ISOString=Symbol("LocalTime_ISOString"),LocalTime_value=Symbol("LocalTime_value"),LocalTime_get=(e,t,r)=>+e[LocalTime_ISOString].slice(t,r),LocalTime_set=(e,t,r,n)=>{e[LocalTime_value]=Value(e[LocalTime_ISOString]=e[LocalTime_ISOString].slice(0,t)+(""+n).padStart(2,"0")+e[LocalTime_ISOString].slice(r))},LocalTime=fpc(class extends Datetime{[LocalTime_ISOString];[LocalTime_value];valueOf(){return this[LocalTime_value]}toISOString(){return this[LocalTime_ISOString]}constructor(e){return IS_LOCAL_TIME(e)||throws(SyntaxError$1(`Invalid Local Time ${e}`+where(" at "))),super(),this[LocalTime_value]=Value(this[LocalTime_ISOString]=e),this}getHours(){return LocalTime_get(this,0,2)}setHours(e){return LocalTime_set(this,0,2,e)}getMinutes(){return LocalTime_get(this,3,5)}setMinutes(e){return LocalTime_set(this,3,5,e)}getSeconds(){return LocalTime_get(this,6,8)}setSeconds(e){return LocalTime_set(this,6,8,e)}getMilliseconds(){return+this[LocalTime_value].slice(6,9).padEnd(3,"0")}setMilliseconds(e){this[LocalTime_value]=Value(this[LocalTime_ISOString]=this[LocalTime_ISOString].slice(0,8)+(e?("."+(""+e).padStart(3,"0")).replace(DOT_ZERO,""):""))}}),parseInt$1=parseInt,fromCodePoint=String.fromCodePoint,ESCAPED_IN_SINGLE_LINE=/[^\\]+|\\(?:[\\"btnfr/]|u.{4}|U.{8})/gs,ESCAPED_IN_MULTI_LINE=/[^\n\\]+|\n|\\(?:[\t ]*\n[\t\n ]*|[\\"btnfr/]|u.{4}|U.{8})/gs,BasicString=e=>{if(!e)return"";const t=e.match(ESCAPED_IN_SINGLE_LINE),{length:r}=t;let n=0;do{const e=t[n];if("\\"===e[0])switch(e[1]){case"\\":t[n]="\\";break;case'"':t[n]='"';break;case"b":t[n]="\b";break;case"t":t[n]="\t";break;case"n":t[n]="\n";break;case"f":t[n]="\f";break;case"r":t[n]="\r";break;case"u":const r=parseInt$1(e.slice(2),16);55295<r&&r<57344&&throws(RangeError$1(`Invalid Unicode Scalar ${e}`+where(" at "))),t[n]=fromCharCode(r);break;case"U":const i=parseInt$1(e.slice(2),16);(55295<i&&i<57344||1114111<i)&&throws(RangeError$1(`Invalid Unicode Scalar ${e}`+where(" at "))),t[n]=fromCodePoint(i);break;case"/":t[n]="/"}}while(++n!==r);return t.join("")},MultilineBasicString=(e,t)=>{if(!e)return"";const r=e.match(ESCAPED_IN_MULTI_LINE),{length:n}=r;let i=0;do{const e=r[i];if("\n"===e)r[i]=useWhatToJoinMultilineString;else if("\\"===e[0])switch(e[1]){case"\n":case" ":case"\t":r[i]="";break;case"\\":r[i]="\\";break;case'"':r[i]='"';break;case"b":r[i]="\b";break;case"t":r[i]="\t";break;case"n":r[i]="\n";break;case"f":r[i]="\f";break;case"r":r[i]="\r";break;case"u":const n=parseInt$1(e.slice(2),16);55295<n&&n<57344&&throws(RangeError$1(`Invalid Unicode Scalar ${e}`+where(" at ",lineIndex+i+t))),r[i]=fromCharCode(n);break;case"U":const a=parseInt$1(e.slice(2),16);(55295<a&&a<57344||1114111<a)&&throws(RangeError$1(`Invalid Unicode Scalar ${e}`+where(" at ",lineIndex+i+t))),r[i]=fromCodePoint(a);break;case"/":r[i]="/"}}while(++i!==n);return r.join("")},BigInt$1=BigInt,INTEGER_D=/[-+]?(?:0|[1-9][_\d]*)/,BAD_D=(()=>newRegExp`_(?!\d)`.test)(),IS_D_INTEGER=(()=>newRegExp`^${INTEGER_D}$`.test)(),IS_XOB_INTEGER=(()=>theRegExp(/^0(?:x[\dA-Fa-f][_\dA-Fa-f]*|o[0-7][_0-7]*|b[01][_01]*)$/).test)(),BAD_XOB=(()=>newRegExp`_(?![\dA-Fa-f])`.test)(),UNDERSCORES_SIGN=/_|^[-+]/g,BigIntInteger=e=>{(IS_D_INTEGER(e)||IS_XOB_INTEGER(e))&&!BAD_XOB(e)||throws(SyntaxError$1(`Invalid Integer ${e}`+where(" at ")));let t=BigInt$1(e.replace(UNDERSCORES_SIGN,""));return"-"===e[0]&&(t=-t),allowLonger||-9223372036854775808n<=t&&t<=9223372036854775807n||throws(RangeError$1(`Integer expect 64 bit range (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807), not includes ${e}`+where(" meet at "))),t},NumberInteger=e=>{(IS_D_INTEGER(e)||IS_XOB_INTEGER(e))&&!BAD_XOB(e)||throws(SyntaxError$1(`Invalid Integer ${e}`+where(" at ")));const t="-"===e[0]?-e.replace(UNDERSCORES_SIGN,""):+e.replace(UNDERSCORES_SIGN,"");return isSafeInteger(t)||throws(RangeError$1(`Integer did not use BitInt must fit Number.isSafeInteger, not includes ${e}`+where(" meet at "))),t},Integer=e=>{if(!0===usingBigInt)return BigIntInteger(e);if(!1===usingBigInt)return NumberInteger(e);const t=BigIntInteger(e);return IntegerMin<=t&&t<=IntegerMax?+(t+""):t},isFinite$1=isFinite,IS_FLOAT=(()=>newRegExp`
	^
	${INTEGER_D}
	(?:
		\.\d[_\d]*
		(?:[eE][-+]?\d[_\d]*)?
	|
		[eE][-+]?\d[_\d]*
	)
	$`.test)(),UNDERSCORES=/_/g,IS_ZERO=(()=>theRegExp(/^[-+]?0(?:\.[0_]+)?(?:[eE][-+]?0+)?$/).test)(),Float=e=>{IS_FLOAT(e)&&!BAD_D(e)||throws(SyntaxError$1(`Invalid Float ${e}`+where(" at ")));const t=+e.replace(UNDERSCORES,"");return sError&&(isFinite$1(t)||throws(RangeError$1(`Float has been as big as inf, like ${e}`+where(" at "))),t||IS_ZERO(e)||throws(RangeError$1(`Float has been as little as ${"-"===e[0]?"-":""}0, like ${e}`+where(" at ")))),t},prepareTable=(e,t)=>{const{length:r}=t;let n=0;for(;n<r;){const i=t[n++];if(!(i in e)){for(e=e[i]=new Table(!1);n<r;)e=e[t[n++]]=new Table(!1);return e}isTable(e=e[i])?isInline(e)&&throws(Error$1("Trying to define Table under static Inline Table"+where(" at "))):isArray(e)?(isStatic(e)&&throws(Error$1("Trying to append value to static Inline Array"+where(" at "))),e=e[e.length-1]):throws(Error$1("Trying to define Table under non-Table value"+where(" at ")))}return e},appendTable=(e,t,r,n)=>{let i;if(r){let r;t in e?isArray(r=e[t])&&!isStatic(r)||throws(Error$1("Trying to push Table to non-ArrayOfTables value"+where(" at "))):r=e[t]=newArray(!1),n&&collect(n,r,e,t),r[r.length]=i=new Table(!0)}else t in e?(i=e[t],directlyIfNot(i)||throws(Error$1("Duplicate Table definition"+where(" at "))),fromPair(i)&&throws(Error$1("A table defined implicitly via key/value pair can not be accessed to via []"+where(", which at ")))):e[t]=i=new Table(!0),n&&collect(n,null,e,t);return i},prepareInlineTable=(e,t)=>{const{length:r}=t;let n=0;for(;n<r;){const i=t[n++];if(!(i in e)){for(e=e[i]=new Table(!1,!0);n<r;)e=e[t[n++]]=new Table(!1,!0);return e}isTable(e=e[i])||throws(Error$1("Trying to assign property through non-Table value"+where(" at "))),isInline(e)&&throws(Error$1("Trying to assign property through static Inline Table"+where(" at "))),fromPair(e)||throws(Error$1("A table defined implicitly via [] can not be accessed to via key/value pair"+where(", which at ")))}return e},checkLiteralString=e=>(__CONTROL_CHARACTER_EXCLUDE_test(e)&&throws(SyntaxError$1("Control characters other than Tab are not permitted in a Literal String"+where(", which was found at "))),e),assignLiteralString=(e,t,r)=>{if("'"!==r[1]||"'"!==r[2]){const n=LITERAL_STRING_exec(r)??throws(SyntaxError$1("Bad literal string"+where(" at ")));return e[t]=checkLiteralString(n[1]),n[2]}r=r.slice(3);const n=__MULTI_LINE_LITERAL_STRING_exec(r);if(n)return e[t]=checkLiteralString(n[1])+n[2],n[3];const i=r?[checkLiteralString(r)]:[];for(const a=mark("Literal String");;){const r=must(a),n=__MULTI_LINE_LITERAL_STRING_exec(r);if(n)return i[i.length]=checkLiteralString(n[1])+n[2],e[t]=i.join(useWhatToJoinMultilineString),n[3];i[i.length]=r}},assignBasicString=(e,t,r)=>{if('"'!==r[1]||'"'!==r[2]){const n=BASIC_STRING_exec_1(r);return e[t]=BasicString(n),r.slice(2+n.length).replace(PRE_WHITESPACE,"")}r=r.slice(3);const n=MULTI_LINE_BASIC_STRING_exec_0(r);let{length:i}=n;if(r.startsWith('"""',i))return ESCAPED_EXCLUDE_CONTROL_CHARACTER_test(n)||throws(SyntaxError$1("Bad multi-line basic string"+where(" at "))),i+=3,e[t]=BasicString(n)+(endsWithQuote&&'"'===r[i]?'"'===r[++i]?(++i,'""'):'"':""),r.slice(i).replace(PRE_WHITESPACE,"");const a=r?1:0;a&&(ESCAPED_EXCLUDE_CONTROL_CHARACTER_test(r+="\n")||throws(SyntaxError$1("Bad multi-line basic string"+where(" at "))));const s=a?[r]:[];for(const l=mark("Basic String");;){let r=must(l);const n=MULTI_LINE_BASIC_STRING_exec_0(r);let{length:i}=n;if(r.startsWith('"""',i))return ESCAPED_EXCLUDE_CONTROL_CHARACTER_test(n)||throws(SyntaxError$1("Bad multi-line basic string"+where(" at "))),i+=3,e[t]=MultilineBasicString(s.join("")+n,a)+(endsWithQuote&&'"'===r[i]?'"'===r[++i]?(++i,'""'):'"':""),r.slice(i).replace(PRE_WHITESPACE,"");ESCAPED_EXCLUDE_CONTROL_CHARACTER_test(r+="\n")||throws(SyntaxError$1("Bad multi-line basic string"+where(" at "))),s[s.length]=r}},Symbol_=Symbol,KEYS=Null$1(null),Sym=e=>{const t=Symbol_(e);return KEYS[t]=e,KEYS[e]=t},commentFor=e=>KEYS[e]??Sym(e),NEWLINE=/\r?\n/g,getComment=(e,t)=>{if(t in KEYS&&KEYS[t]in e){const r=e[KEYS[t]];if("string"==typeof r)return" #"+r.replace(NEWLINE,"");throw TypeError$1(`the value of commentKey must be "string" type, while "${null===r?"null":typeof r}" is found`)}return""},IS_OFFSET$=(()=>theRegExp(OFFSET$).test)(),parseKeys=e=>{const t=[];let r=-1;for(;;){if(e||throws(SyntaxError$1("Empty bare key"+where(" at "))),'"'===e[0]){const n=BASIC_STRING_exec_1(e);e=e.slice(2+n.length),t[++r]=BasicString(n)}else{const n="'"===e[0],i=((n?__LITERAL_KEY_exec:__BARE_KEY_exec)(e)??throws(SyntaxError$1(`Bad ${n?"literal string":"bare"} key`+where(" at "))))[0];e=e.slice(i.length),t[++r]=n?i.slice(1,-1):i}if(!IS_DOT_KEY(e))break;e=e.replace(DOT_KEY,"")}if(disallowEmptyKey){let e=r;do{t[e]||throws(SyntaxError$1("Empty key is not allowed before TOML v0.5"+where(", which at ")))}while(e--)}const n=t[r];return t.length=r,{leadingKeys:t,finalKey:n,lineRest:e}},push=(e,t)=>{if("<"===t[0]){const{1:r}=({2:t}=_VALUE_PAIR_exec(t)??throws(SyntaxError$1("Bad tag "+where(" at "))));switch(collect(r,e,null),t&&t[0]){case",":case"]":case"":case"#":return e[e.length]=void 0,t}}switch(t[0]){case"'":return assignLiteralString(asStrings(e),e.length,t);case'"':return assignBasicString(asStrings(e),e.length,t);case"{":return inlineTable||throws(SyntaxError$1("Inline Table is not allowed before TOML v0.4"+where(", which at "))),equalInlineTable(asTables(e),e.length,t);case"[":return equalStaticArray(asArrays(e),e.length,t)}const{1:r}=({2:t}=VALUE_REST_exec(t)??throws(SyntaxError$1("Bad atom value"+where(" at "))));if(sFloat){if("inf"===r||"+inf"===r)return asFloats(e)[e.length]=1/0,t;if("-inf"===r)return asFloats(e)[e.length]=-1/0,t;if("nan"===r||"+nan"===r||"-nan"===r)return asFloats(e)[e.length]=0/0,t}return r.includes(":")?(r.includes("-")?IS_OFFSET$(r)?asOffsetDateTimes(e)[e.length]=new OffsetDateTime(r):(moreDatetime||throws(SyntaxError$1("Local Date-Time is not allowed before TOML v0.5"+where(", which at "))),asLocalDateTimes(e)[e.length]=new LocalDateTime(r)):(moreDatetime||throws(SyntaxError$1("Local Time is not allowed before TOML v0.5"+where(", which at "))),asLocalTimes(e)[e.length]=new LocalTime(r)),t):r.indexOf("-")!==r.lastIndexOf("-")&&"-"!==r[0]?(moreDatetime||throws(SyntaxError$1("Local Date is not allowed before TOML v0.5"+where(", which at "))),asLocalDates(e)[e.length]=new LocalDate(r),t):("true"===r?asBooleans(e)[e.length]=!0:"false"===r?asBooleans(e)[e.length]=!1:r.includes(".")||(r.includes("e")||r.includes("E"))&&!r.startsWith("0x")?asFloats(e)[e.length]=Float(r):enableNull&&"null"===r?asNulls(e)[e.length]=null:asIntegers(e)[e.length]=Integer(r),t)},equalStaticArray=function*(e,t,r){const n=e[t]=newArray(!0),i=mark("Inline Array");r=r.replace(SYM_WHITESPACE,"");let a=!0;for(;!r||"#"===r[0];)a=!1,r=must(i).replace(PRE_WHITESPACE,"");if("]"===r[0])return a&&beInline(n,!0),r.replace(SYM_WHITESPACE,"");for(;;){const e=push(n,r);for(r="string"==typeof e?e:yield e;!r||"#"===r[0];)a=!1,r=must(i).replace(PRE_WHITESPACE,"");if(","===r[0]){for(r=r.replace(SYM_WHITESPACE,"");!r||"#"===r[0];)a=!1,r=must(i).replace(PRE_WHITESPACE,"");if("]"===r[0])break}else{if("]"===r[0])break;throws(SyntaxError$1("Unexpect character in static array item value"+where(", which is found at ")))}}return a&&beInline(n,!0),r.replace(SYM_WHITESPACE,"")},equalInlineTable=function*(e,t,r){const n=e[t]=new Table(!0,!0);if(r=r.replace(SYM_WHITESPACE,""),allowInlineTableMultilineAndTrailingCommaEvenNoComma){const e=mark("Inline Table");let t=!0;for(;;){for(;!r||"#"===r[0];)t=!1,r=must(e).replace(PRE_WHITESPACE,"");if("}"===r[0])break;const i=ForComment(n,r),a=assign(i);if(r="string"==typeof a?a:yield a){if("#"===r[0]){preserveComment&&(i.table[commentFor(i.finalKey)]=r.slice(1)),t=!1;do{r=must(e).replace(PRE_WHITESPACE,"")}while(!r||"#"===r[0])}}else{t=!1;do{r=must(e).replace(PRE_WHITESPACE,"")}while(!r||"#"===r[0])}","===r[0]&&(r=r.replace(SYM_WHITESPACE,""))}t||beInline(n,!1)}else if(r||throws(SyntaxError$1("Inline Table is intended to appear on a single line"+where(", which broken at "))),"}"!==r[0])for(;;){"#"===r[0]&&throws(SyntaxError$1("Inline Table is intended to appear on a single line"+where(", which broken at ")));const e=assign(ForComment(n,r));if("}"===(r=("string"==typeof e?e:yield e)||throws(SyntaxError$1("Inline Table is intended to appear on a single line"+where(", which broken at "))))[0])break;","===r[0]&&"}"===(r=r.replace(SYM_WHITESPACE,"")||throws(SyntaxError$1("Inline Table is intended to appear on a single line"+where(", which broken at "))))[0]&&throws(SyntaxError$1("The last property of an Inline Table can not have a trailing comma"+where(", which was found at ")))}return r.replace(SYM_WHITESPACE,"")},ForComment=(e,t)=>{const{leadingKeys:r,finalKey:n,tag:i}=({lineRest:t}=KEY_VALUE_PAIR_exec_groups(parseKeys(t)));return{table:prepareInlineTable(e,r),finalKey:n,tag:i,lineRest:t}},assign=({finalKey:e,tag:t,lineRest:r,table:n})=>{if(e in n&&throws(Error$1("Duplicate property definition"+where(" at "))),t)switch(collect(t,null,n,e),r&&r[0]){case",":case"}":case"":case"#":return n[e]=void 0,r}switch(r&&r[0]){case"'":return assignLiteralString(n,e,r);case'"':return assignBasicString(n,e,r);case"{":return inlineTable||throws(SyntaxError$1("Inline Table is not allowed before TOML v0.4"+where(", which at "))),equalInlineTable(n,e,r);case"[":return equalStaticArray(n,e,r)}const{1:i}=({2:r}=VALUE_REST_exec(r)??throws(SyntaxError$1("Bad atom value"+where(" at "))));if(sFloat){if("inf"===i||"+inf"===i)return n[e]=1/0,r;if("-inf"===i)return n[e]=-1/0,r;if("nan"===i||"+nan"===i||"-nan"===i)return n[e]=0/0,r}return i.includes(":")?(i.includes("-")?IS_OFFSET$(i)?n[e]=new OffsetDateTime(i):(moreDatetime||throws(SyntaxError$1("Local Date-Time is not allowed before TOML v0.5"+where(", which at "))),n[e]=new LocalDateTime(i)):(moreDatetime||throws(SyntaxError$1("Local Time is not allowed before TOML v0.5"+where(", which at "))),n[e]=new LocalTime(i)),r):i.indexOf("-")!==i.lastIndexOf("-")&&"-"!==i[0]?(moreDatetime||throws(SyntaxError$1("Local Date is not allowed before TOML v0.5"+where(", which at "))),n[e]=new LocalDate(i),r):(n[e]="true"===i||"false"!==i&&(i.includes(".")||(i.includes("e")||i.includes("E"))&&!i.startsWith("0x")?Float(i):enableNull&&"null"===i?null:Integer(i)),r)},Root=()=>{const e=new Table;let t=e;for(;lineIndex!==lastLineIndex;){const r=sourceLines[++lineIndex].replace(PRE_WHITESPACE,"");if(r)if("["===r[0]){const{leadingKeys:n,finalKey:i,asArrayItem:a,tag:s,lineRest:l}=TABLE_DEFINITION_exec_groups(r,parseKeys),o=prepareTable(e,n);l&&("#"===l[0]?preserveComment&&!a&&(o[commentFor(i)]=l.slice(1)):throws(SyntaxError$1("Unexpect charachtor after table header"+where(" at ")))),t=appendTable(o,i,a,s)}else if("#"===r[0])__CONTROL_CHARACTER_EXCLUDE_test(r)&&throws(SyntaxError$1("Control characters other than Tab are not permitted in comments"+where(", which was found at ")));else{const e=ForComment(t,r);let n=assign(e);"string"==typeof n||(n=x(n)),n&&("#"===n[0]?preserveComment&&(e.table[commentFor(e.finalKey)]=n.slice(1)):throws(SyntaxError$1("Unexpect charachtor after key/value pair"+where(" at "))))}}return e},IS_NON_SCALAR=(()=>theRegExp(NON_SCALAR).test)(),BOM="\ufeff",buf2str=e=>{const t=e.toString();if(!from(t).equals(e))throw Error$1("A TOML doc must be a (ful-scalar) valid UTF-8 file, without any unknown code point.");return t&&"\ufeff"===t[0]?t.slice(1):t},parse=(e,t,r,n,i)=>{let a;if(could(),isBuffer(e))e=buf2str(e),a="";else if("object"==typeof e&&e){if(a=e.path,"string"!=typeof a)throw TypeError$1("TOML.parse(source.path)");const{data:t}=e;if(void 0===t)e=buf2str(readFileSync(a));else if(isBuffer(t))e=buf2str(t);else{if("string"!=typeof t)throw TypeError$1("TOML.parse(source.data)");e=t}}else{if("string"!=typeof e)throw TypeError$1("TOML.parse(source)");a=""}try{if(IS_NON_SCALAR(e))throw Error$1("A TOML doc must be a (ful-scalar) valid UTF-8 file, without any uncoupled UCS-4 character code.");try{use(t,r,n,i),todo(e,a);try{const e=Root();return process(),e}finally{done()}}finally{processor=null,collection.length=collection_length=0,zeroDatetime=!1}}finally{clearRegExp()}},parse$1=assign$1(((e,t,r,n,i)=>"number"==typeof t?parse(e,t,r,n,i):parse(e,1,t,r,n)),{"1.0":(e,t,r,n)=>parse(e,.1,t,r,n),1:(e,t,r,n)=>parse(e,1,t,r,n),.5:(e,t,r,n)=>parse(e,.5,t,r,n),.4:(e,t,r,n)=>parse(e,.4,t,r,n),.3:(e,t,r,n)=>parse(e,.3,t,r,n),.2:(e,t,r,n)=>parse(e,.2,t,r,n),.1:(e,t,r,n)=>parse(e,.1,t,r,n)}),getOwnPropertyNames=Object.getOwnPropertyNames,Boolean$1=Boolean,String$1=String,Number$1=Number,LITERAL=new WeakSet$1,isLiteral=set_has.bind(LITERAL),beLiteral=set_add.bind(LITERAL),literal=(e,...t)=>{if("string"!=typeof e){let r=t.length;if(r){const{raw:n}=e;for(e=n[r];r;)t[--r]+=n[r];e=t.join("")+e}else e=e.raw[0]}const r=e.split("\n");return beLiteral(r),r},ESCAPED=Null$1({...fromEntries([...Array$1(32)].map(((e,t)=>[fromCharCode(t),"\\u"+t.toString(16).toUpperCase().padStart(4,"0")]))),"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"','"""':'""\\"',"\\":"\\\\","":"\\u007F"}),NEED_BASIC=test.bind(/[\x00-\x08\x0A-\x1F'\x7F]/),BY_ESCAPE=/[^\x00-\x08\x0A-\x1F"\\\x7F]+|./gs,NEED_ESCAPE=test.bind(/^[\x00-\x08\x0A-\x1F"\\\x7F]/),singlelineString=e=>{if(NEED_BASIC(e)){const t=e.match(BY_ESCAPE);let r=t.length;do{NEED_ESCAPE(t[--r])&&(t[r]=ESCAPED[t[r]])}while(r);return`"${t.join("")}"`}return`'${e}'`},NEED_MULTILINE_BASIC=test.bind(/[\x00-\x08\x0A-\x1F\x7F]|'''/),REAL_MULTILINE_ESCAPE=test.bind(/[\x00-\x08\x0A-\x1F\\\x7F]|"""/),BY_MULTILINE_ESCAPE=/[^\x00-\x08\x0A-\x1F"\\\x7F]+|"""|./gs,NEED_MULTILINE_ESCAPE=test.bind(/^(?:[\x00-\x08\x0A-\x1F\\\x7F]|""")/),escape_multiline=(e,t)=>{const r=e[t];if(REAL_MULTILINE_ESCAPE(r)){const n=r.match(BY_MULTILINE_ESCAPE);let i=n.length;do{NEED_MULTILINE_ESCAPE(n[--i])&&(n[i]=ESCAPED[n[i]])}while(i);e[t]=n.join("")}},Lines=e=>(1===(e=["",...e]).length&&(e[1]=""),e),multilineString=e=>{const t=e.length-1;let r=t;do{if(NEED_MULTILINE_BASIC(e[r]))break}while(--r);if(r)for(r=t,escape_multiline(e,r),e[r]+=e[0]='"""';--r;)escape_multiline(e,r);else e[t]+=e[0]="'''";return beLiteral(e),e},multilineBasicString=e=>{let t=e.length-1;for(escape_multiline(e,t),e[t]+=e[0]='"""';--t;)escape_multiline(e,t);return beLiteral(e),e},_Infinity=-1/0,INTEGER_LIKE=test.bind(/^-?\d+$/),ensureFloat=e=>INTEGER_LIKE(e)?e+".0":e,float=e=>e?1/0===e?"inf":e===-1/0?"-inf":ensureFloat(""+e):e==e?is(e,0)?"0.0":"-0.0":"nan",BARE=test.bind(/^[\w-]+$/),$Key$=e=>BARE(e)?e:singlelineString(e);class TOMLSection extends Array$1{document;constructor(e){return super(),this.document=e,this}[Symbol.toPrimitive](){return this.join(this.document.newline)}appendNewline(){this[this.length]=""}set appendLine(e){this[this.length]=e}set appendInline(e){this[this.length-1]+=e}set appendInlineIf(e){e&&(this[this.length-1]+=e)}*assignBlock(e,t,r,n){const{document:i}=this,{newlineUnderHeader:a,newlineUnderSectionButPair:s}=i,l=!!t&&i.newlineUnderPairButDotted,o=t?i.newlineUnderDotted:i.newlineUnderPair;for(const c of n){const n=r[c],_=$Key$(c),u=e+_;if(isArray$1(n)){if(n.length&&isSection(n[0])){const e=`[[${u}]]`,t=u+".";for(const r of n){const n=i.appendSection();n[0]=e,a?(n[1]="",yield n.assignBlock(t,"",r,getOwnPropertyNames(r)),s&&2!==n.length&&n.appendNewline()):(yield n.assignBlock(t,"",r,getOwnPropertyNames(r)),s&&n.appendNewline())}continue}}else if(isSection(n)){const e=i.appendSection();e[0]=`[${u}]${getComment(r,c)}`,a?(e[1]="",yield e.assignBlock(u+".","",n,getOwnPropertyNames(n)),s&&2!==e.length&&e.appendNewline()):(yield e.assignBlock(u+".","",n,getOwnPropertyNames(n)),s&&e.appendNewline());continue}const E=t+_;this.appendLine=E+" = ";const T=this.value("",n,getOwnPropertyNames);T?(--this.length,yield this.assignBlock(u+".",E+".",n,T),l&&this.appendNewline()):(this.appendInlineIf=getComment(r,c),o&&this.appendNewline())}}value(e,t,r){switch(typeof t){case"object":if(null===t){if(this.document.nullDisabled)throw TypeError$1('toml can not stringify "null" type value without truthy options.xNull');this.appendInline="null";break}if(isLiteral(t)){const{length:e}=t;this.appendInline=t[0];let r=1;for(;r!==e;)this.appendLine=t[r++];break}const n=ofInline(t);if(isArray$1(t)){n?this.singlelineArray(e,t):this.staticArray(e,t);break}if(void 0!==n){n||this.document.multilineTableDisabled?this.inlineTable(e,t):this.multilineTable(e,t,this.document.multilineTableComma);break}if(t instanceof TOMLDatetime){this.appendInline=this.document._?t.toISOString().replace("T"," "):t.toISOString();break}if(t instanceof String$1)throw TypeError$1("TOML.stringify refuse to handle [object String]");if(r){const e=r(t);if(e.length)return e;this.appendInline="{ }";break}if(t instanceof BigInt$1)throw TypeError$1("TOML.stringify refuse to handle [object BigInt]");if(t instanceof Number$1)throw TypeError$1("TOML.stringify refuse to handle [object Number]");if(t instanceof Boolean$1)throw TypeError$1("TOML.stringify refuse to handle [object Boolean]");if(t instanceof Symbol_)throw TypeError$1("TOML.stringify refuse to handle [object Symbol]");this.inlineTable(e,t);break;case"bigint":this.appendInline=""+t;break;case"number":this.appendInline=float(t);break;case"string":this.appendInline=singlelineString(t);break;case"boolean":this.appendInline=t?"true":"false";break;default:throw TypeError$1(`toml can not stringify "${typeof t}" type value`)}return null}singlelineArray(e,t){const{length:r}=t;if(r){this.appendInline="[ ",this.value(e,t[0]);let n=1;for(;n!==r;)this.appendInline=", ",this.value(e,t[n++]);this.appendInline=" ]"}else this.appendInline="[ ]"}staticArray(e,t){this.appendInline="[";const r=e+this.document.indent;for(const n of t)this.appendLine=r,this.value(r,n),this.appendInline=",";this.appendLine=e+"]"}inlineTable(e,t){const r=getOwnPropertyNames(t);r.length?(this.appendInline="{ ",this.assignInline(e,t,"",r),this[this.length-1]=this[this.length-1].slice(0,-2)+" }"):this.appendInline="{ }"}multilineTable(e,t,r){this.appendInline="{",this.assignMultiline(e,t,"",getOwnPropertyNames(t),r),this.appendLine=e+"}"}assignInline(e,t,r,n){for(const i of n){const n=t[i],a=r+$Key$(i),s=this.appendInline=a+" = ",l=this.value(e,n,getOwnPropertyNames);l?(this[this.length-1]=this[this.length-1].slice(0,-s.length),this.assignInline(e,n,a+".",l)):this.appendInline=", "}}assignMultiline(e,t,r,n,i){const a=e+this.document.indent;for(const s of n){const n=t[s],l=r+$Key$(s);this.appendLine=a+l+" = ";const o=this.value(a,n,getOwnPropertyNames);o?(--this.length,this.assignMultiline(e,n,l+".",o,i)):i?this.appendInline=","+getComment(t,s):this.appendInlineIf=getComment(t,s)}}}const name2code=Null$1({document:0,section:1,header:2,pairs:3,pair:4}),IS_INDENT=test.bind(/^[\t ]*$/);class TOMLDocument extends Array$1{get["constructor"](){return Array$1}0=new TOMLSection(this);newline;newlineUnderSection;newlineUnderSectionButPair;newlineUnderHeader;newlineUnderPair;newlineUnderPairButDotted;newlineUnderDotted;indent;_;nullDisabled;multilineTableDisabled;multilineTableComma;constructor(e){super();const t=e?.newline;if(void 0!==t&&"\n"!==t&&"\r\n"!==t)throw"string"==typeof t?SyntaxError$1("TOML.stringify(,{newline}) can only be valid TOML newline"):TypeError$1("TOML.stringify(,{newline}) can only be string");this.newline=t??"";const r=name2code[e?.newlineAround??"header"]??name2code.header;this.newlineUnderSection=r>0,this.newlineUnderSectionButPair=1===r||2===r,this.newlineUnderHeader=r>1,this.newlineUnderPair=r>2,this.newlineUnderPairButDotted=3===r,this.newlineUnderDotted=r>3;const n=e?.indent;if(void 0===n)this.indent="\t";else if("string"==typeof n){if(!IS_INDENT(n))throw SyntaxError$1("TOML.stringify(,{indent}) can only include Tab or Space");this.indent=n}else{if("number"!=typeof n)throw TypeError$1(`TOML.stringify(,{indent}) can not be "${typeof n}" type`);if(!isSafeInteger(n))throw RangeError$1(`TOML.stringify(,{indent:${n}}) is out of range`);this.indent=" ".repeat(n)}this._=" "===e?.T,this.nullDisabled=!e?.xNull;const i=e?.xBeforeNewlineInMultilineTable;return""===i?(this.multilineTableDisabled=!1,this.multilineTableComma=!1):","===i?(this.multilineTableDisabled=!1,this.multilineTableComma=!0):(this.multilineTableDisabled=!0,this.multilineTableComma=!0),this}appendSection(){return this[this.length]=new TOMLSection(this)}}const stringify=(e,t)=>{const r=new TOMLDocument(t),n=r[0];return n[0]="",x(n.assignBlock("","",e,getOwnPropertyNames(e))),r.newlineUnderSectionButPair&&1!==n.length&&n.appendNewline(),r.newlineUnderSection||r[r.length-1].appendNewline(),r.newline?r.join(r.newline):r.flat()},multiline=(()=>{const e=e=>"string"==typeof e?multilineString(("\n"+e).split("\n")):isArray$1(e)?multilineString(Lines(e)):multilineTable(e);return e.basic=e=>multilineBasicString("string"==typeof e?("\n"+e).split("\n"):Lines(e)),freeze(e),e})(),_export=Default({version,parse:parse$1,stringify,Section,inline,multiline,literal,commentFor,OffsetDateTime,LocalDateTime,LocalDate,LocalTime});export default _export;export{LocalDate,LocalDateTime,LocalTime,OffsetDateTime,Section,commentFor,inline,literal,multiline,parse$1 as parse,stringify,version};
//# sourceMappingURL=j-toml.min.js.map