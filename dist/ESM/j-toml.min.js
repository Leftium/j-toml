/*!@preserve@license
 * 模块名称：j-toml
 * 模块功能：龙腾道为汤小明语写的实现。从属于“简计划”。
   　　　　　An implementation of TOML written by LongTengDao. Belong to "Plan J".
 * 模块版本：1.17.0
 * 许可条款：LGPL-3.0
 * 所属作者：龙腾道 <LongTengDao@LongTengDao.com> (www.LongTengDao.com)
 * 问题反馈：https://GitHub.com/LongTengDao/j-toml/issues
 * 项目主页：https://GitHub.com/LongTengDao/j-toml/
 */
const version="1.17.0",Error$1=Error,TypeError$1=TypeError,assign$1=Object.assign,undefined$1=void 0,bind=Function.prototype.bind,test=RegExp.prototype.test,exec=RegExp.prototype.exec,SyntaxError$1=SyntaxError,RegExp$1=RegExp,freeze=Object.freeze,Reflect_apply=Reflect.apply,Proxy$1=Proxy,create$1=Object.create,NULL=Object.seal?Object.preventExtensions(Object.create(null)):null,toStringTag="undefined"==typeof Symbol?undefined$1:Symbol.toStringTag,Object_defineProperty=Object.defineProperty,isArray$1=Array.isArray,Infinity=1/0,fromCharCode=String.fromCharCode,Array$1=Array,hasOwnProperty=Object.prototype.hasOwnProperty,propertyIsEnumerable=Object.prototype.propertyIsEnumerable;var isEnum=propertyIsEnumerable.call.bind(propertyIsEnumerable),hasOwn=function(){return hasOwnProperty.bind?hasOwnProperty.call.bind(hasOwnProperty):function(e,t){return hasOwnProperty.call(e,t)}}(),create=Object.create;const Default=function(e,t){if(t||(t=e,e=create$1(NULL)),assign$1)assign$1(e,t);else for(var r in t)hasOwn(t,r)&&(e[r]=t[r]);if(e.default=e,toStringTag){var n=create$1(NULL);n.value="Module",Object_defineProperty(e,toStringTag,n)}return"function"==typeof e&&e.prototype&&freeze(e.prototype),freeze(e)};var Test=bind?bind.bind(test):function(e){return function(t){return test.call(e,t)}},Exec=bind?bind.bind(exec):function(e){return function(t){return exec.call(e,t)}};function theRegExp(e){var t=e.test=Test(e),r=e.exec=Exec(e),n=t.source=r.source=e.source;return t.unicode=r.unicode=e.unicode,t.ignoreCase=r.ignoreCase=e.ignoreCase,t.multiline=r.multiline=n.indexOf("^")<0&&n.indexOf("$")<0?null:e.multiline,t.dotAll=r.dotAll=n.indexOf(".")<0?null:e.dotAll,e}var NT=/[\n\t]+/g,ESCAPE=/\\./g;function graveAccentReplacer(e){return"\\`"===e?"`":e}var includes="".includes?function(e,t){return e.includes(t)}:function(e,t){return e.indexOf(t)>-1};function RE(e){for(var t=this.U,r=this.I,n=this.M,i=this.S,a=e.raw,s=a[0].replace(NT,""),l=1,o=arguments.length;l!==o;){var c=arguments[l];if("string"==typeof c)s+=c;else{var _=c.source;if("string"!=typeof _)throw TypeError$1("source");if(c.unicode===t)throw SyntaxError$1("unicode");if(c.ignoreCase===r)throw SyntaxError$1("ignoreCase");if(c.multiline===n&&(includes(_,"^")||includes(_,"$")))throw SyntaxError$1("multiline");if(c.dotAll===i&&includes(_,"."))throw SyntaxError$1("dotAll");s+=_}s+=a[l++].replace(NT,"")}var u=RegExp$1(t?s=s.replace(ESCAPE,graveAccentReplacer):s,this.flags),E=u.test=Test(u),T=u.exec=Exec(u);return E.source=T.source=s,E.unicode=T.unicode=t,E.ignoreCase=T.ignoreCase=r,E.multiline=T.multiline=includes(s,"^")||includes(s,"$")?n:null,E.dotAll=T.dotAll=includes(s,".")?i:null,u}var RE_bind=bind&&bind.bind(RE);function Context(e){return{U:!includes(e,"u"),I:!includes(e,"i"),M:!includes(e,"m"),S:!includes(e,"s"),flags:e}}var CONTEXT=Context(""),newRegExp=Proxy$1?new Proxy$1(RE,{apply:function(e,t,r){return Reflect_apply(e,CONTEXT,r)},get:function(e,t){return RE_bind(Context(t))},defineProperty:function(){return!1},preventExtensions:function(){return!1}}):function(){RE.apply=RE.apply;for(var e=function(){return RE.apply(CONTEXT,arguments)},t=63;t--;)!function(t){e[t.flags]=function(){return RE.apply(t,arguments)}}(Context((32&t?"":"g")+(16&t?"":"i")+(8&t?"":"m")+(4&t?"":"s")+(2&t?"":"u")+(1&t?"":"y")));return freeze?freeze(e):e}(),clearRegExp="$_"in RegExp$1?function(){var e=/^/;return e.test=e.test,function(t){return e.test(""),t}}():function(e){return e};const NONE=[];let sourcePath="",sourceLines=NONE,lastLineIndex=-1,lineIndex=-1;const throws=e=>{throw e},EOL=/\r?\n/,todo=(e,t)=>{if("string"!=typeof t)throw TypeError$1("TOML.parse(,,,,sourcePath)");sourcePath=t,sourceLines=e.split(EOL),lastLineIndex=sourceLines.length-1,lineIndex=-1},next=()=>sourceLines[++lineIndex],rest=()=>lineIndex!==lastLineIndex;class mark{lineIndex=lineIndex;type;restColumn;constructor(e,t){return this.type=e,this.restColumn=t,this}must(){return lineIndex===lastLineIndex&&throws(SyntaxError$1(`${this.type} is not close until the end of the file`+where(", which started from ",this.lineIndex,sourceLines[this.lineIndex].length-this.restColumn+1))),sourceLines[++lineIndex]}nowrap(){throws(Error$1("TOML.parse(,,multilineStringJoiner) must be passed, while the source including multi-line string"+where(", which started from ",this.lineIndex,sourceLines[this.lineIndex].length-this.restColumn+1)))}}const where=(e,t=lineIndex,r=0)=>sourceLines===NONE?"":sourcePath?`\n    at (${sourcePath}:${t+1}:${r})`:`${e}line ${t+1}: ${sourceLines[t]}`,done=()=>{sourcePath="",sourceLines=NONE},RangeError$1=RangeError,WeakMap$1=WeakMap,get=WeakMap.prototype.get,set=WeakMap.prototype.set,isSafeInteger=Number.isSafeInteger,ownKeys=Reflect.ownKeys,MAX_SAFE_INTEGER=Number.MAX_SAFE_INTEGER,MIN_SAFE_INTEGER=Number.MIN_SAFE_INTEGER,WeakSet$1=WeakSet,set_has=WeakSet.prototype.has,set_add=WeakSet.prototype.add,del=WeakSet.prototype.delete,Object_keys=Object.keys,getOwnPropertySymbols=Object.getOwnPropertySymbols,Null$1=function(){var e=Object.assign||function(e,t){var r,n,i;for(r=Object_keys(t),n=0;n<r.length;++n)e[i=r[n]]=t[i];if(getOwnPropertySymbols)for(r=getOwnPropertySymbols(t),n=0;n<r.length;++n)isEnum(t,i=r[n])&&([i]=t[i]);return e};function t(e){return delete e.prototype.constructor,freeze(e.prototype),e}var r=function(r){return r===undefined$1?this:"function"==typeof r?t(r):e(create(NULL),r)};return delete r.name,r.prototype=null,freeze(r),r}(),is=Object.is,fromEntries=Object.fromEntries,Reflect_construct=Reflect.construct,Reflect_defineProperty=Reflect.defineProperty,Reflect_deleteProperty=Reflect.deleteProperty,Keeper=()=>[],hasOwnProperty_call=hasOwnProperty.call.bind(hasOwnProperty),newWeakMap=()=>{const e=new WeakMap$1;return e.has=e.has,e.get=e.get,e.set=e.set,e},target2keeper=newWeakMap(),proxy2target=newWeakMap(),target2proxy=newWeakMap(),handlers=assign$1(create$1(NULL),{defineProperty:(e,t,r)=>{if(hasOwnProperty_call(e,t))return Reflect_defineProperty(e,t,assign$1(create$1(NULL),r));if(Reflect_defineProperty(e,t,assign$1(create$1(NULL),r))){const r=target2keeper.get(e);return r[r.length]=t,!0}return!1},deleteProperty:(e,t)=>{if(Reflect_deleteProperty(e,t)){const r=target2keeper.get(e),n=r.indexOf(t);return n<0||--r.copyWithin(n,n+1).length,!0}return!1},ownKeys:e=>target2keeper.get(e),construct:(e,t,r)=>orderify(Reflect_construct(e,t,r)),apply:(e,t,r)=>orderify(Reflect_apply(e,t,r))}),newProxy=(e,t)=>{target2keeper.set(e,t);const r=new Proxy$1(e,handlers);return proxy2target.set(r,e),r},orderify=e=>{if(proxy2target.has(e))return e;let t=target2proxy.get(e);return t||(t=newProxy(e,assign$1([],ownKeys(e))),target2proxy.set(e,t),t)},Null=function(){function e(){throw TypeError$1("Super constructor Null cannot be invoked with 'new'")}function t(){throw TypeError$1("Super constructor Null cannot be invoked without 'new'")}const r=e=>(delete e.prototype.constructor,freeze(e.prototype),e);function n(i){return new.target?new.target===n?e():newProxy(this,[]):"function"==typeof i?r(i):t()}return n.prototype=null,Object_defineProperty(n,"name",assign$1(create$1(NULL),{value:"",configurable:!1})),freeze(n),n}(),map_has=WeakMap.prototype.has,INLINES=new WeakMap$1,isInline=map_has.bind(INLINES),ofInline=get.bind(INLINES),beInline=set.bind(INLINES),inline=e=>(beInline(e,!0),e),multilineTable=e=>(beInline(e,!1),e),SECTIONS=new WeakSet$1,isSection=set_has.bind(SECTIONS),beSection=set_add.bind(SECTIONS),Section=e=>{if(isArray$1(e))throw TypeError$1("array can not be section, maybe you want to use it on the tables in it");return beSection(e),e},INLINE=!0,tables=new WeakSet$1,tables_add=set_add.bind(tables),isTable=set_has.bind(tables),implicitTables=new WeakSet$1,implicitTables_add=set_add.bind(implicitTables),implicitTables_del=del.bind(implicitTables),directlyIfNot=e=>!!implicitTables_del(e)&&(beSection(e),!0),DIRECTLY=!0,IMPLICITLY=!1,pairs=new WeakSet$1,pairs_add=set_add.bind(pairs),fromPair=set_has.bind(pairs),PAIR=!0,PlainTable=Null$1(class extends Null$1{constructor(e,t){return super(),tables_add(this),e?t?beInline(this,!0):beSection(this):(t?pairs_add:implicitTables_add)(this),this}}),OrderedTable=Null$1(class extends Null{constructor(e,t){return super(),tables_add(this),e?t?beInline(this,!0):beSection(this):(t?pairs_add:implicitTables_add)(this),this}}),Whitespace=/[ \t]/,PRE_WHITESPACE=(()=>newRegExp`
	^${Whitespace}+`)(),VALUE_REST_exec=(()=>newRegExp.s`
	^
	(
		(?:\d\d\d\d-\d\d-\d\d \d)?
		[\w\-+.:]+
	)
	${Whitespace}*
	(.*)
	$`.exec)(),LITERAL_STRING_exec=(()=>newRegExp.s`
	^
	'([^']*)'
	${Whitespace}*
	(.*)`.exec)(),MULTI_LINE_LITERAL_STRING_0_1_2=(()=>newRegExp.s`
	^
	(.*?)
	'''('{0,2})
	${Whitespace}*
	(.*)`.exec)(),MULTI_LINE_LITERAL_STRING_0=(()=>newRegExp.s`
	^
	(.*?)
	'''()
	${Whitespace}*
	(.*)`.exec)();let __MULTI_LINE_LITERAL_STRING_exec=MULTI_LINE_LITERAL_STRING_0;const SYM_WHITESPACE=(()=>newRegExp.s`
	^
	.
	${Whitespace}*`)(),Tag=/[^\x00-\x1F"#'()<>[\\\]`{}\x7F]+/,KEY_VALUE_PAIR_exec=(()=>newRegExp.s`
	^
	${Whitespace}*
	=
	${Whitespace}*
	(?:
		<(${Tag})>
		${Whitespace}*
	)?
	(.*)
	$`.exec)(),_VALUE_PAIR_exec=(()=>newRegExp.s`
	^
	<(${Tag})>
	${Whitespace}*
	(.*)
	$`.exec)(),TAG_REST_exec=(()=>newRegExp.s`
	^
	<(${Tag})>
	${Whitespace}*
	(.*)
	$`.exec)(),MULTI_LINE_BASIC_STRING=theRegExp(/(?:[^\\"]+|\\.|""?(?!")){1,10}/ys),MULTI_LINE_BASIC_STRING_exec_0=e=>{let t=MULTI_LINE_BASIC_STRING.lastIndex=0;for(;MULTI_LINE_BASIC_STRING.test(e);)t=MULTI_LINE_BASIC_STRING.lastIndex;return e.slice(0,t)},ESCAPED_EXCLUDE_CONTROL_CHARACTER_TAB______=/[^\\\x00-\x08\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|[\t ]*\n[\t\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g,ESCAPED_EXCLUDE_CONTROL_CHARACTER__________=/[^\\\x00-\x09\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]| *\n[\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g,ESCAPED_EXCLUDE_CONTROL_CHARACTER_DEL______=/[^\\\x00-\x09\x0B-\x1F]+|\\(?:[btnfr"\\]|\n[\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g,ESCAPED_EXCLUDE_CONTROL_CHARACTER_DEL_SLASH=/[^\\\x00-\x09\x0B-\x1F]+|\\(?:[btnfr"\\/]|\n[\n ]*|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})/g;let __ESCAPED_EXCLUDE_CONTROL_CHARACTER=ESCAPED_EXCLUDE_CONTROL_CHARACTER_TAB______;const ESCAPED_EXCLUDE_CONTROL_CHARACTER_test=e=>!e.replace(__ESCAPED_EXCLUDE_CONTROL_CHARACTER,""),BASIC_STRING_TAB______=theRegExp(/(?:[^\\"\x00-\x08\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})){1,10}/y),BASIC_STRING__________=theRegExp(/(?:[^\\"\x00-\x09\x0B-\x1F\x7F]+|\\(?:[btnfr"\\]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})){1,10}/y),BASIC_STRING_DEL______=theRegExp(/(?:[^\\"\x00-\x09\x0B-\x1F]+|\\(?:[btnfr"\\]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})){1,10}/y),BASIC_STRING_DEL_SLASH=theRegExp(/(?:[^\\"\x00-\x09\x0B-\x1F]+|\\(?:[btnfr"\\/]|u[\dA-Fa-f]{4}|U[\dA-Fa-f]{8})){1,10}/y);let __BASIC_STRING=BASIC_STRING_DEL_SLASH;const BASIC_STRING_exec_1=e=>{let t=__BASIC_STRING.lastIndex=1;for(;__BASIC_STRING.test(e);)t=__BASIC_STRING.lastIndex;return t!==e.length&&'"'===e[t]||throws(SyntaxError$1("Bad basic string"+where(" at "))),e.slice(1,t)},IS_DOT_KEY=(()=>theRegExp(/^[ \t]*\./).test)(),DOT_KEY=/^[ \t]*\.[ \t]*/,BARE_KEY_STRICT=(()=>theRegExp(/^[\w-]+/).exec)(),BARE_KEY_FREE=(()=>theRegExp(/^[^ \t#=[\]'".]+(?:[ \t]+[^ \t#=[\]'".]+)*/).exec)();let __BARE_KEY_exec=BARE_KEY_FREE;const LITERAL_KEY____=(()=>theRegExp(/^'[^'\x00-\x08\x0B-\x1F\x7F]*'/).exec)(),LITERAL_KEY_DEL=(()=>theRegExp(/^'[^'\x00-\x08\x0B-\x1F]*'/).exec)();let __LITERAL_KEY_exec=LITERAL_KEY_DEL,supportArrayOfTables=!0;const TABLE_DEFINITION_exec_groups=(e,t)=>{const r="["===e[1];r?(supportArrayOfTables||throws(SyntaxError$1("Array of Tables is not allowed before TOML v0.2"+where(", which at "))),e=e.slice(2)):e=e.slice(1),e=e.replace(PRE_WHITESPACE,"");const{leadingKeys:n,finalKey:i}=({lineRest:e}=t(e));let a;return(e=e.replace(PRE_WHITESPACE,""))&&"]"===e[0]||throws(SyntaxError$1("Table header is not closed"+where(", which is found at "))),(e.length>1?"]"===e[1]===r:!r)||throws(SyntaxError$1("Square brackets of Table definition statement not match"+where(" at "))),(e=e.slice(r?2:1).replace(PRE_WHITESPACE,""))&&"<"===e[0]?({1:a,2:e}=TAG_REST_exec(e)??throws(SyntaxError$1("Bad tag"+where(" at ")))):a="",{leadingKeys:n,finalKey:i,asArrayItem:r,tag:a,lineRest:e}},KEY_VALUE_PAIR_exec_groups=({leadingKeys:e,finalKey:t,lineRest:r})=>{const{1:n=""}=({2:r}=KEY_VALUE_PAIR_exec(r)??throws(SyntaxError$1("Keys must equal something"+where(", but missing at "))));return n||r&&"#"!==r[0]||throws(SyntaxError$1("Value can not be missing after euqal sign"+where(", which is found at "))),{leadingKeys:e,finalKey:t,tag:n,lineRest:r}},CONTROL_CHARACTER_EXCLUDE_TAB____=(()=>theRegExp(/[\x00-\x08\x0B-\x1F\x7F]/).test)(),CONTROL_CHARACTER_EXCLUDE_TAB_DEL=(()=>theRegExp(/[\x00-\x08\x0B-\x1F]/).test)();let __CONTROL_CHARACTER_EXCLUDE_test=CONTROL_CHARACTER_EXCLUDE_TAB____;const switchRegExp=e=>{switch(e){case 1:__MULTI_LINE_LITERAL_STRING_exec=MULTI_LINE_LITERAL_STRING_0_1_2,__LITERAL_KEY_exec=LITERAL_KEY____,__CONTROL_CHARACTER_EXCLUDE_test=CONTROL_CHARACTER_EXCLUDE_TAB____,__ESCAPED_EXCLUDE_CONTROL_CHARACTER=ESCAPED_EXCLUDE_CONTROL_CHARACTER_TAB______,__BASIC_STRING=BASIC_STRING_TAB______,__BARE_KEY_exec=BARE_KEY_STRICT,supportArrayOfTables=!0;break;case.5:__MULTI_LINE_LITERAL_STRING_exec=MULTI_LINE_LITERAL_STRING_0,__LITERAL_KEY_exec=LITERAL_KEY____,__CONTROL_CHARACTER_EXCLUDE_test=CONTROL_CHARACTER_EXCLUDE_TAB____,__ESCAPED_EXCLUDE_CONTROL_CHARACTER=ESCAPED_EXCLUDE_CONTROL_CHARACTER__________,__BASIC_STRING=BASIC_STRING__________,__BARE_KEY_exec=BARE_KEY_STRICT,supportArrayOfTables=!0;break;case.4:__MULTI_LINE_LITERAL_STRING_exec=MULTI_LINE_LITERAL_STRING_0,__LITERAL_KEY_exec=LITERAL_KEY_DEL,__CONTROL_CHARACTER_EXCLUDE_test=CONTROL_CHARACTER_EXCLUDE_TAB_DEL,__ESCAPED_EXCLUDE_CONTROL_CHARACTER=ESCAPED_EXCLUDE_CONTROL_CHARACTER_DEL______,__BASIC_STRING=BASIC_STRING_DEL______,__BARE_KEY_exec=BARE_KEY_STRICT,supportArrayOfTables=!0;break;default:__MULTI_LINE_LITERAL_STRING_exec=MULTI_LINE_LITERAL_STRING_0,__LITERAL_KEY_exec=LITERAL_KEY_DEL,__CONTROL_CHARACTER_EXCLUDE_test=CONTROL_CHARACTER_EXCLUDE_TAB_DEL,__ESCAPED_EXCLUDE_CONTROL_CHARACTER=ESCAPED_EXCLUDE_CONTROL_CHARACTER_DEL_SLASH,__BASIC_STRING=BASIC_STRING_DEL_SLASH,__BARE_KEY_exec=BARE_KEY_FREE,supportArrayOfTables=!1}};let endsWithQuote,zeroDatetime,inlineTable,moreDatetime,disallowEmptyKey,sError,sFloat,Table,allowLonger,enableNull,allowInlineTableMultilineAndTrailingCommaEvenNoComma,preserveComment,disableDigit,useWhatToJoinMultilineString=null,usingBigInt=!0,IntegerMin=0,IntegerMax=0;const arrayTypes=new WeakMap$1,arrayTypes_get=get.bind(arrayTypes),arrayTypes_set=set.bind(arrayTypes),As=()=>{const e=t=>{const r=arrayTypes_get(t);return r?r===e||throws(TypeError$1("Types in Array must be same"+where(". Check "))):arrayTypes_set(t,e),t};return e},AS_TYPED={asNulls:As(),asStrings:As(),asTables:As(),asArrays:As(),asBooleans:As(),asFloats:As(),asIntegers:As(),asOffsetDateTimes:As(),asLocalDateTimes:As(),asLocalDates:As(),asLocalTimes:As()},asMixed=e=>e;let asNulls,asStrings,asTables,asArrays,asBooleans,asFloats,asIntegers,asOffsetDateTimes,asLocalDateTimes,asLocalDates,asLocalTimes,processor=null,collection=[],collection_length=0;const collect_on=(e,t,r,n)=>{const i=create$1(NULL);i.tag=e,r&&(i.table=r,i.key=n),t&&(i.array=t,i.index=t.length),collection[collection_length++]=i},collect_off=()=>{throws(SyntaxError$1("xOptions.tag is not enabled, but found tag syntax"+where(" at ")))};let collect=collect_off;const Process=()=>{if(collection_length){let e=collection_length;const t=processor,r=collection;return collection=[],()=>{do{t(r[--e]),r.length=e}while(e)}}return null},clear=()=>{processor=null,collection.length=collection_length=0,zeroDatetime=!1,useWhatToJoinMultilineString=null},use=(e,t,r,n)=>{let i;switch(e){case 1:i=endsWithQuote=moreDatetime=sFloat=inlineTable=!0,zeroDatetime=disallowEmptyKey=!1;break;case.5:moreDatetime=sFloat=inlineTable=!0,i=endsWithQuote=zeroDatetime=disallowEmptyKey=!1;break;case.4:disallowEmptyKey=inlineTable=!0,i=endsWithQuote=zeroDatetime=moreDatetime=sFloat=!1;break;case.3:disallowEmptyKey=!0,i=endsWithQuote=zeroDatetime=moreDatetime=sFloat=inlineTable=!1;break;case.2:case.1:zeroDatetime=disallowEmptyKey=!0,i=endsWithQuote=moreDatetime=sFloat=inlineTable=!1;break;default:throw RangeError$1("TOML.parse(,specificationVersion)")}if(switchRegExp(e),"string"==typeof t)useWhatToJoinMultilineString=t;else{if(t!==undefined$1)throw TypeError$1("TOML.parse(,,multilineStringJoiner)");useWhatToJoinMultilineString=null}if(r===undefined$1||!0===r)usingBigInt=!0;else if(!1===r)usingBigInt=!1;else{if("number"!=typeof r)throw TypeError$1("TOML.parse(,,,useBigInt)");if(!isSafeInteger(r))throw RangeError$1("TOML.parse(,,,useBigInt)");if(usingBigInt=null,r>=0?IntegerMin=-(IntegerMax=r):IntegerMax=-(IntegerMin=r)-1,IntegerMin<MIN_SAFE_INTEGER||MAX_SAFE_INTEGER<IntegerMax)throw RangeError$1("TOML.parse(,,,useBigInt)")}if(null==n||!1===n)Table=PlainTable,sError=allowLonger=enableNull=allowInlineTableMultilineAndTrailingCommaEvenNoComma=!1,collect=collect_off;else if(!0===n)Table=OrderedTable,allowLonger=sError=enableNull=allowInlineTableMultilineAndTrailingCommaEvenNoComma=!0,collect=collect_off;else if("function"==typeof n){if(Table=OrderedTable,allowLonger=sError=enableNull=allowInlineTableMultilineAndTrailingCommaEvenNoComma=!0,!i)throw TypeError$1("TOML.parse(,,,,tag) needs at least TOML 1.0 to support mixed type array");processor=n,collect=collect_on}else{const{order:e,longer:t,exact:r,null:a,multi:s,comment:l,string:o,tag:c,..._}=n;if(ownKeys(_).length)throw TypeError$1("TOML.parse(,,,,xOptions)");if(Table=e?OrderedTable:PlainTable,allowLonger=!!t,sError=!!r,enableNull=!!a,allowInlineTableMultilineAndTrailingCommaEvenNoComma=!!s,preserveComment=!!l,disableDigit=!!o,c){if("function"!=typeof c)throw TypeError$1("TOML.parse(,,,,xOptions.tag)");if(!i)throw TypeError$1("TOML.parse(,,,,xOptions) xOptions.tag needs at least TOML 1.0 to support mixed type array");processor=c,collect=collect_on}else collect=collect_off}i?asNulls=asStrings=asTables=asArrays=asBooleans=asFloats=asIntegers=asOffsetDateTimes=asLocalDateTimes=asLocalDates=asLocalTimes=asMixed:({asNulls,asStrings,asTables,asArrays,asBooleans,asFloats,asIntegers,asOffsetDateTimes,asLocalDateTimes,asLocalDates,asLocalTimes}=AS_TYPED)},NaN=0/0,previous=Symbol("previous"),x=e=>{let t=e,r=t.next();if(!r.done)for(r.value[previous]=t,r=(t=r.value).next();;)if(r.done){if(t===e)break;t=t[previous],r=t.next(r.value)}else r.value[previous]=t,r=(t=r.value).next();return r.value},arrays=new WeakSet$1,arrays_add=set_add.bind(arrays),isArray=set_has.bind(arrays),OF_TABLES=!1,STATICALLY=!0,staticalArrays=new WeakSet$1,staticalArrays_add=set_add.bind(staticalArrays),isStatic=set_has.bind(staticalArrays),newArray=e=>{const t=[];return arrays_add(t),e&&staticalArrays_add(t),t},TOMLDatetime=Date,parse$2=Date.parse,preventExtensions=Object.preventExtensions,fpc=e=>(freeze(freeze(e).prototype),e),_29_=/(?:0[1-9]|1\d|2\d)/,_30_=/(?:0[1-9]|[12]\d|30)/,_31_=/(?:0[1-9]|[12]\d|3[01])/,_23_=/(?:[01]\d|2[0-3])/,_59_=/[0-5]\d/,YMD=(()=>newRegExp`
	\d\d\d\d-
	(?:
		0
		(?:
			[13578]-${_31_}
			|
			[469]-${_30_}
			|
			2-${_29_}
		)
		|
		1
		(?:
			[02]-${_31_}
			|
			1-${_30_}
		)
	)
`)(),HMS=(()=>newRegExp`
	${_23_}:${_59_}:${_59_}
`)(),OFFSET$=/(?:Z|[+-]\d\d:\d\d)$/,Z_exec=(()=>theRegExp(/(([+-])\d\d):(\d\d)$/).exec)(),OFFSET_DATETIME_exec=(()=>newRegExp`
	^
	${YMD}
	[T ]
	${HMS}
	(?:\.\d{1,3}(\d*?)0*)?
	(?:Z|[+-]${_23_}:${_59_})
	$`.exec)(),OFFSET_DATETIME_ZERO_exec=(()=>newRegExp`
	^
	${YMD}
	[T ]
	${HMS}
	()
	Z
	$`.exec)(),IS_LOCAL_DATETIME=(()=>newRegExp`
	^
	${YMD}
	[T ]
	${HMS}
	(?:\.\d+)?
	$`.test)(),IS_LOCAL_DATE=(()=>newRegExp`
	^
	${YMD}
	$`.test)(),IS_LOCAL_TIME=(()=>newRegExp`
	^
	${HMS}
	(?:\.\d+)?
	$`.test)(),DOT_ZERO=/\.?0+$/,DELIMITER_DOT=/[-T:.]/g,ZERO=/(?<=\.\d*)0+$/,Datetime=(()=>{const e=function(){return this},t=Null$1(null);{const e=Null$1(null);for(const r of ownKeys(TOMLDatetime.prototype))"constructor"===r||"toJSON"===r||(t[r]=e)}return e.prototype=preventExtensions(create$1(TOMLDatetime.prototype,t)),freeze(e)})(),Value=e=>e.replace(ZERO,"").replace(DELIMITER_DOT,""),leap=e=>"02-29"!==e.slice(5,10)||+e.slice(0,4)%4==0&&"00"!==e.slice(2,4),DATE=new TOMLDatetime(0),OffsetDateTime_ISOString=Symbol("OffsetDateTime_ISOString"),OffsetDateTime_value=Symbol("OffsetDateTime_value"),OffsetDateTime_use=(e,t=0)=>(DATE.setTime(+e[OffsetDateTime_value]+t),DATE),OffsetDateTime_get=(e,t,r)=>+e[OffsetDateTime_ISOString].slice(t,r),OffsetDateTime_set=(e,t,r,n)=>{r&&(e[OffsetDateTime_ISOString]=e[OffsetDateTime_ISOString].slice(0,t)+(""+n).padStart(r-t,"0")+e[OffsetDateTime_ISOString].slice(r));const i=parse$2(e[OffsetDateTime_ISOString]);return e[OffsetDateTime_value]=(""+i).padStart(15,"0")+e[OffsetDateTime_value].slice(15),i},OffsetDateTime=fpc(class extends Datetime{[OffsetDateTime_ISOString];[OffsetDateTime_value];valueOf(){return this[OffsetDateTime_value]}toISOString(){return this[OffsetDateTime_ISOString]}constructor(e){const{1:t}=leap(e)&&(zeroDatetime?OFFSET_DATETIME_ZERO_exec:OFFSET_DATETIME_exec)(e)||throws(SyntaxError$1(`Invalid Offset Date-Time ${e}`+where(" at ")));return super(),this[OffsetDateTime_ISOString]=e.replace(" ","T"),this[OffsetDateTime_value]=(""+parse$2(this[OffsetDateTime_ISOString])).padStart(15,"0")+(t?"."+t:""),this}getUTCFullYear(){return OffsetDateTime_use(this).getUTCFullYear()}getFullYear(){return OffsetDateTime_get(this,0,4)}setFullYear(e){return OffsetDateTime_set(this,0,4,e)}getUTCMonth(){return OffsetDateTime_use(this).getUTCMonth()}getMonth(){return OffsetDateTime_get(this,5,7)-1}setMonth(e){return OffsetDateTime_set(this,5,7,e+1)}getUTCDate(){return OffsetDateTime_use(this).getUTCDate()}getDate(){return OffsetDateTime_get(this,8,10)}setDate(e){return OffsetDateTime_set(this,8,10,e)}getUTCHours(){return OffsetDateTime_use(this).getUTCHours()}getHours(){return OffsetDateTime_get(this,11,13)}setHours(e){return OffsetDateTime_set(this,11,13,e)}getUTCMinutes(){return OffsetDateTime_use(this).getUTCMinutes()}getMinutes(){return OffsetDateTime_get(this,14,16)}setMinutes(e){return OffsetDateTime_set(this,14,16,e)}getUTCSeconds(){return OffsetDateTime_use(this).getUTCSeconds()}getSeconds(){return OffsetDateTime_get(this,17,19)}setSeconds(e){return OffsetDateTime_set(this,17,19,e)}getUTCMilliseconds(){return OffsetDateTime_use(this).getUTCMilliseconds()}getMilliseconds(){return+this[OffsetDateTime_value].slice(12,15)}setMilliseconds(e){return this[OffsetDateTime_ISOString]=this[OffsetDateTime_ISOString].slice(0,19)+(e?("."+(""+e).padStart(3,"0")).replace(DOT_ZERO,""):"")+this[OffsetDateTime_ISOString].slice(this[OffsetDateTime_ISOString].search(OFFSET$)),OffsetDateTime_set(this,0,0,0)}getUTCDay(){return OffsetDateTime_use(this).getUTCDay()}getDay(){return OffsetDateTime_use(this,6e4*this.getTimezoneOffset()).getUTCDay()}getTimezoneOffset(){const e=Z_exec(this[OffsetDateTime_ISOString]);return e?60*+e[1]+ +(e[2]+e[3]):0}setTimezoneOffset(e){let t=OffsetDateTime_use(this,6e4*(e=+e)).toISOString().slice(0,-1);if(e){e>0?t+="+":(t+="-",e=-e);const r=e%60,n=(e-r)/60;this[OffsetDateTime_ISOString]=t+(n>9?n:"0"+n)+(r>9?":"+r:":0"+r)}else this[OffsetDateTime_ISOString]=t+(is(e,0)?"Z":"-00:00")}getTime(){return+this[OffsetDateTime_value].slice(0,15)}setTime(e){e=DATE.setTime(e);const t=Z_exec(this[OffsetDateTime_ISOString]);return DATE.setTime(e+6e4*(t?60*+t[1]+ +(t[2]+t[3]):0)),this[OffsetDateTime_ISOString]=t?DATE.toISOString().slice(0,-1)+t[0]:DATE.toISOString(),this[OffsetDateTime_value]=(""+e).padStart(15,"0"),e}}),LocalDateTime_ISOString=Symbol("LocalDateTime_ISOString"),LocalDateTime_value=Symbol("LocalDateTime_value"),LocalDateTime_get=(e,t,r)=>+e[LocalDateTime_ISOString].slice(t,r),LocalDateTime_set=(e,t,r,n)=>{e[LocalDateTime_value]=Value(e[LocalDateTime_ISOString]=e[LocalDateTime_ISOString].slice(0,t)+(""+n).padStart(r-t,"0")+e[LocalDateTime_ISOString].slice(r))},LocalDateTime=fpc(class extends Datetime{[LocalDateTime_ISOString];[LocalDateTime_value];valueOf(){return this[LocalDateTime_value]}toISOString(){return this[LocalDateTime_ISOString]}constructor(e){return IS_LOCAL_DATETIME(e)&&leap(e)||throws(SyntaxError$1(`Invalid Local Date-Time ${e}`+where(" at "))),super(),this[LocalDateTime_value]=Value(this[LocalDateTime_ISOString]=e.replace(" ","T")),this}getFullYear(){return LocalDateTime_get(this,0,4)}setFullYear(e){return LocalDateTime_set(this,0,4,e)}getMonth(){return LocalDateTime_get(this,5,7)-1}setMonth(e){return LocalDateTime_set(this,5,7,e+1)}getDate(){return LocalDateTime_get(this,8,10)}setDate(e){return LocalDateTime_set(this,8,10,e)}getHours(){return LocalDateTime_get(this,11,13)}setHours(e){return LocalDateTime_set(this,11,13,e)}getMinutes(){return LocalDateTime_get(this,14,16)}setMinutes(e){return LocalDateTime_set(this,14,16,e)}getSeconds(){return LocalDateTime_get(this,17,19)}setSeconds(e){return LocalDateTime_set(this,17,19,e)}getMilliseconds(){return+this[LocalDateTime_value].slice(14,17).padEnd(3,"0")}setMilliseconds(e){this[LocalDateTime_value]=Value(this[LocalDateTime_ISOString]=this[LocalDateTime_ISOString].slice(0,19)+(e?("."+(""+e).padStart(3,"0")).replace(DOT_ZERO,""):""))}}),LocalDate_ISOString=Symbol("LocalDate_ISOString"),LocalDate_value=Symbol("LocalDate_value"),LocalDate_get=(e,t,r)=>+e[LocalDate_ISOString].slice(t,r),LocalDate_set=(e,t,r,n)=>{e[LocalDate_value]=Value(e[LocalDate_ISOString]=e[LocalDate_ISOString].slice(0,t)+(""+n).padStart(r-t,"0")+e[LocalDate_ISOString].slice(r))},LocalDate=fpc(class extends Datetime{[LocalDate_ISOString];[LocalDate_value];valueOf(){return this[LocalDate_value]}toISOString(){return this[LocalDate_ISOString]}constructor(e){return IS_LOCAL_DATE(e)&&leap(e)||throws(SyntaxError$1(`Invalid Local Date ${e}`+where(" at "))),super(),this[LocalDate_value]=Value(this[LocalDate_ISOString]=e),this}getFullYear(){return LocalDate_get(this,0,4)}setFullYear(e){return LocalDate_set(this,0,4,e)}getMonth(){return LocalDate_get(this,5,7)-1}setMonth(e){return LocalDate_set(this,5,7,e+1)}getDate(){return LocalDate_get(this,8,10)}setDate(e){return LocalDate_set(this,8,10,e)}}),LocalTime_ISOString=Symbol("LocalTime_ISOString"),LocalTime_value=Symbol("LocalTime_value"),LocalTime_get=(e,t,r)=>+e[LocalTime_ISOString].slice(t,r),LocalTime_set=(e,t,r,n)=>{e[LocalTime_value]=Value(e[LocalTime_ISOString]=e[LocalTime_ISOString].slice(0,t)+(""+n).padStart(2,"0")+e[LocalTime_ISOString].slice(r))},LocalTime=fpc(class extends Datetime{[LocalTime_ISOString];[LocalTime_value];valueOf(){return this[LocalTime_value]}toISOString(){return this[LocalTime_ISOString]}constructor(e){return IS_LOCAL_TIME(e)||throws(SyntaxError$1(`Invalid Local Time ${e}`+where(" at "))),super(),this[LocalTime_value]=Value(this[LocalTime_ISOString]=e),this}getHours(){return LocalTime_get(this,0,2)}setHours(e){return LocalTime_set(this,0,2,e)}getMinutes(){return LocalTime_get(this,3,5)}setMinutes(e){return LocalTime_set(this,3,5,e)}getSeconds(){return LocalTime_get(this,6,8)}setSeconds(e){return LocalTime_set(this,6,8,e)}getMilliseconds(){return+this[LocalTime_value].slice(6,9).padEnd(3,"0")}setMilliseconds(e){this[LocalTime_value]=Value(this[LocalTime_ISOString]=this[LocalTime_ISOString].slice(0,8)+(e?("."+(""+e).padStart(3,"0")).replace(DOT_ZERO,""):""))}}),parseInt$1=parseInt,fromCodePoint=String.fromCodePoint,ESCAPED_IN_SINGLE_LINE=/[^\\]+|\\(?:[\\"btnfr/]|u.{4}|U.{8})/gs,ESCAPED_IN_MULTI_LINE=/[^\n\\]+|\n|\\(?:[\t ]*\n[\t\n ]*|[\\"btnfr/]|u.{4}|U.{8})/gs,BasicString=e=>{if(!e)return"";const t=e.match(ESCAPED_IN_SINGLE_LINE),{length:r}=t;let n=0;do{const e=t[n];if("\\"===e[0])switch(e[1]){case"\\":t[n]="\\";break;case'"':t[n]='"';break;case"b":t[n]="\b";break;case"t":t[n]="\t";break;case"n":t[n]="\n";break;case"f":t[n]="\f";break;case"r":t[n]="\r";break;case"u":const r=parseInt$1(e.slice(2),16);55295<r&&r<57344&&throws(RangeError$1(`Invalid Unicode Scalar ${e}`+where(" at "))),t[n]=fromCharCode(r);break;case"U":const i=parseInt$1(e.slice(2),16);(55295<i&&i<57344||1114111<i)&&throws(RangeError$1(`Invalid Unicode Scalar ${e}`+where(" at "))),t[n]=fromCodePoint(i);break;case"/":t[n]="/"}}while(++n!==r);return t.join("")},MultilineBasicString=(e,t,r)=>{if(!e)return"";const n=e.match(ESCAPED_IN_MULTI_LINE),{length:i}=n;let a=0;do{const e=n[a];if("\n"===e)++r,n[a]=t;else if("\\"===e[0])switch(e[1]){case"\n":case" ":case"\t":for(let n=0;n=e.indexOf("\n",n)+1;)++r;n[a]="";break;case"\\":n[a]="\\";break;case'"':n[a]='"';break;case"b":n[a]="\b";break;case"t":n[a]="\t";break;case"n":n[a]="\n";break;case"f":n[a]="\f";break;case"r":n[a]="\r";break;case"u":const t=parseInt$1(e.slice(2),16);55295<t&&t<57344&&throws(RangeError$1(`Invalid Unicode Scalar ${e}`+where(" at ",lineIndex+r))),n[a]=fromCharCode(t);break;case"U":const i=parseInt$1(e.slice(2),16);(55295<i&&i<57344||1114111<i)&&throws(RangeError$1(`Invalid Unicode Scalar ${e}`+where(" at ",lineIndex+r))),n[a]=fromCodePoint(i);break;case"/":n[a]="/"}}while(++a!==i);return n.join("")},BigInt$1=BigInt,INTEGER_D=/[-+]?(?:0|[1-9][_\d]*)/,BAD_D=(()=>newRegExp`_(?!\d)`.test)(),IS_D_INTEGER=(()=>newRegExp`^${INTEGER_D}$`.test)(),IS_XOB_INTEGER=(()=>theRegExp(/^0(?:x[\dA-Fa-f][_\dA-Fa-f]*|o[0-7][_0-7]*|b[01][_01]*)$/).test)(),BAD_XOB=(()=>newRegExp`_(?![\dA-Fa-f])`.test)(),UNDERSCORES_SIGN=/_|^[-+]/g,IS_INTEGER=e=>(IS_D_INTEGER(e)||IS_XOB_INTEGER(e))&&!BAD_XOB(e),BigIntInteger=e=>{IS_INTEGER(e)||throws(SyntaxError$1(`Invalid Integer ${e}`+where(" at ")));let t=BigInt$1(e.replace(UNDERSCORES_SIGN,""));return"-"===e[0]&&(t=-t),allowLonger||-9223372036854775808n<=t&&t<=9223372036854775807n||throws(RangeError$1(`Integer expect 64 bit range (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807), not includes ${e}`+where(" meet at "))),t},NumberInteger=e=>{IS_INTEGER(e)||throws(SyntaxError$1(`Invalid Integer ${e}`+where(" at ")));const t="-"===e[0]?-e.replace(UNDERSCORES_SIGN,""):+e.replace(UNDERSCORES_SIGN,"");return isSafeInteger(t)||throws(RangeError$1(`Integer did not use BitInt must fit Number.isSafeInteger, not includes ${e}`+where(" meet at "))),t},Integer=e=>{if(!0===usingBigInt)return BigIntInteger(e);if(!1===usingBigInt)return NumberInteger(e);const t=BigIntInteger(e);return IntegerMin<=t&&t<=IntegerMax?+(t+""):t},isFinite$1=isFinite,IS_FLOAT=(()=>newRegExp`
	^
	${INTEGER_D}
	(?:
		\.\d[_\d]*
		(?:[eE][-+]?\d[_\d]*)?
	|
		[eE][-+]?\d[_\d]*
	)
	$`.test)(),UNDERSCORES=/_/g,IS_ZERO=(()=>theRegExp(/^[-+]?0(?:\.[0_]+)?(?:[eE][-+]?0+)?$/).test)(),IS_XXX=(()=>theRegExp(/^(?:-?(?:inf|nan)|true|false|null)$/).test)(),IS_FLOAT_OR_XXXX=e=>IS_FLOAT(e)?!BAD_D(e):IS_XXX(e),Float=e=>{IS_FLOAT(e)&&!BAD_D(e)||throws(SyntaxError$1(`Invalid Float ${e}`+where(" at ")));const t=+e.replace(UNDERSCORES,"");return sError&&(isFinite$1(t)||throws(RangeError$1(`Float has been as big as inf, like ${e}`+where(" at "))),t||IS_ZERO(e)||throws(RangeError$1(`Float has been as little as ${"-"===e[0]?"-":""}0, like ${e}`+where(" at ")))),t},prepareTable=(e,t)=>{const{length:r}=t;let n=0;for(;n<r;){const i=t[n++];if(!(i in e)){for(e=e[i]=new Table(!1);n<r;)e=e[t[n++]]=new Table(!1);return e}isTable(e=e[i])?isInline(e)&&throws(Error$1("Trying to define Table under Inline Table"+where(" at "))):isArray(e)?(isStatic(e)&&throws(Error$1("Trying to append value to Static Array"+where(" at "))),e=e[e.length-1]):throws(Error$1("Trying to define Table under non-Table value"+where(" at ")))}return e},appendTable=(e,t,r,n)=>{let i;if(r){let r;t in e?isArray(r=e[t])&&!isStatic(r)||throws(Error$1("Trying to push Table to non-ArrayOfTables value"+where(" at "))):r=e[t]=newArray(!1),n&&collect(n,r,e,t),r[r.length]=i=new Table(!0)}else t in e?(i=e[t],directlyIfNot(i)||throws(Error$1("Duplicate Table definition"+where(" at "))),fromPair(i)&&throws(Error$1("A table defined implicitly via key/value pair can not be accessed to via []"+where(", which at ")))):e[t]=i=new Table(!0),n&&collect(n,null,e,t);return i},prepareInlineTable=(e,t)=>{const{length:r}=t;let n=0;for(;n<r;){const i=t[n++];if(!(i in e)){for(e=e[i]=new Table(!1,!0);n<r;)e=e[t[n++]]=new Table(!1,!0);return e}isTable(e=e[i])||throws(Error$1("Trying to assign property through non-Table value"+where(" at "))),isInline(e)&&throws(Error$1("Trying to assign property through static Inline Table"+where(" at "))),fromPair(e)||throws(Error$1("A table defined implicitly via [] can not be accessed to via key/value pair"+where(", which at ")))}return e},checkLiteralString=e=>(__CONTROL_CHARACTER_EXCLUDE_test(e)&&throws(SyntaxError$1("Control characters other than Tab are not permitted in a Literal String"+where(", which was found at "))),e),assignLiteralString=(e,t,r)=>{if("'"!==r[1]||"'"!==r[2]){const n=LITERAL_STRING_exec(r)??throws(SyntaxError$1("Bad literal string"+where(" at ")));return e[t]=checkLiteralString(n[1]),n[2]}r=r.slice(3);const n=__MULTI_LINE_LITERAL_STRING_exec(r);if(n)return e[t]=checkLiteralString(n[1])+n[2],n[3];const i=new mark("Multi-line Literal String",r.length+3);if(!r){r=i.must();const n=__MULTI_LINE_LITERAL_STRING_exec(r);if(n)return e[t]=checkLiteralString(n[1])+n[2],n[3]}useWhatToJoinMultilineString??i.nowrap();for(const a=[checkLiteralString(r)];;){const r=i.must(),n=__MULTI_LINE_LITERAL_STRING_exec(r);if(n)return a[a.length]=checkLiteralString(n[1])+n[2],e[t]=a.join(useWhatToJoinMultilineString),n[3];a[a.length]=checkLiteralString(r)}},assignBasicString=(e,t,r)=>{if('"'!==r[1]||'"'!==r[2]){const n=BASIC_STRING_exec_1(r);return e[t]=BasicString(n),r.slice(2+n.length).replace(PRE_WHITESPACE,"")}r=r.slice(3);const n=MULTI_LINE_BASIC_STRING_exec_0(r);let{length:i}=n;if(r.startsWith('"""',i))return ESCAPED_EXCLUDE_CONTROL_CHARACTER_test(n)||throws(SyntaxError$1("Bad multi-line basic string"+where(" at "))),i+=3,e[t]=BasicString(n)+(endsWithQuote&&'"'===r[i]?'"'===r[++i]?(++i,'""'):'"':""),r.slice(i).replace(PRE_WHITESPACE,"");const a=new mark("Multi-line Basic String",r.length+3),s=r?0:1;if(s){r=a.must();const n=MULTI_LINE_BASIC_STRING_exec_0(r);let{length:i}=n;if(r.startsWith('"""',i))return ESCAPED_EXCLUDE_CONTROL_CHARACTER_test(n)||throws(SyntaxError$1("Bad multi-line basic string"+where(" at "))),i+=3,e[t]=MultilineBasicString(n,useWhatToJoinMultilineString,s)+(endsWithQuote&&'"'===r[i]?'"'===r[++i]?(++i,'""'):'"':""),r.slice(i).replace(PRE_WHITESPACE,"")}useWhatToJoinMultilineString??a.nowrap(),ESCAPED_EXCLUDE_CONTROL_CHARACTER_test(r+="\n")||throws(SyntaxError$1("Bad multi-line basic string"+where(" at ")));for(const l=[r];;){let r=a.must();const n=MULTI_LINE_BASIC_STRING_exec_0(r);let{length:i}=n;if(r.startsWith('"""',i))return ESCAPED_EXCLUDE_CONTROL_CHARACTER_test(n)||throws(SyntaxError$1("Bad multi-line basic string"+where(" at "))),i+=3,e[t]=MultilineBasicString(l.join("")+n,useWhatToJoinMultilineString,s)+(endsWithQuote&&'"'===r[i]?'"'===r[++i]?(++i,'""'):'"':""),r.slice(i).replace(PRE_WHITESPACE,"");ESCAPED_EXCLUDE_CONTROL_CHARACTER_test(r+="\n")||throws(SyntaxError$1("Bad multi-line basic string"+where(" at "))),l[l.length]=r}},Symbol_=Symbol,KEYS=Null$1(null),Sym=e=>{const t=Symbol_(e);return KEYS[t]=e,KEYS[e]=t},commentFor=e=>KEYS[e]??Sym(e),NEWLINE=/\r?\n/g,getComment=(e,t)=>{if(t in KEYS&&KEYS[t]in e){const r=e[KEYS[t]];if("string"==typeof r)return" #"+r.replace(NEWLINE,"");throw TypeError$1(`the value of commentKey must be "string" type, while "${null===r?"null":typeof r}" is found`)}return""},IS_OFFSET$=(()=>theRegExp(OFFSET$).test)(),parseKeys=e=>{let t=e;const r=[];let n=-1;for(;;){if(t||throws(SyntaxError$1("Empty bare key"+where(" at "))),'"'===t[0]){const e=BASIC_STRING_exec_1(t);t=t.slice(2+e.length),r[++n]=BasicString(e)}else{const e="'"===t[0],i=((e?__LITERAL_KEY_exec:__BARE_KEY_exec)(t)??throws(SyntaxError$1(`Bad ${e?"literal string":"bare"} key`+where(" at "))))[0];t=t.slice(i.length),r[++n]=e?i.slice(1,-1):i}if(!IS_DOT_KEY(t))break;t=t.replace(DOT_KEY,"")}if(disableDigit){const r=e.slice(0,-t.length);(IS_INTEGER(r)||IS_FLOAT_OR_XXXX(r))&&throws(SyntaxError$1("Bad bare key disabled by xOptions.string"+where(" at ")))}if(disallowEmptyKey){let e=n;do{r[e]||throws(SyntaxError$1("Empty key is not allowed before TOML v0.5"+where(", which at ")))}while(e--)}const i=r[n];return r.length=n,{leadingKeys:r,finalKey:i,lineRest:t}},push=(e,t)=>{if("<"===t[0]){const{1:r}=({2:t}=_VALUE_PAIR_exec(t)??throws(SyntaxError$1("Bad tag "+where(" at "))));switch(collect(r,e,null),t&&t[0]){case",":case"]":case"":case"#":return e[e.length]=undefined$1,t}}switch(t[0]){case"'":return assignLiteralString(asStrings(e),e.length,t);case'"':return assignBasicString(asStrings(e),e.length,t);case"{":return inlineTable||throws(SyntaxError$1("Inline Table is not allowed before TOML v0.4"+where(", which at "))),equalInlineTable(asTables(e),e.length,t);case"[":return equalStaticArray(asArrays(e),e.length,t)}const{1:r}=({2:t}=VALUE_REST_exec(t)??throws(SyntaxError$1("Bad atom value"+where(" at "))));if(sFloat){if("inf"===r||"+inf"===r)return asFloats(e)[e.length]=1/0,t;if("-inf"===r)return asFloats(e)[e.length]=-1/0,t;if("nan"===r||"+nan"===r||"-nan"===r)return asFloats(e)[e.length]=0/0,t}return r.includes(":")?(r.includes("-")?IS_OFFSET$(r)?asOffsetDateTimes(e)[e.length]=new OffsetDateTime(r):(moreDatetime||throws(SyntaxError$1("Local Date-Time is not allowed before TOML v0.5"+where(", which at "))),asLocalDateTimes(e)[e.length]=new LocalDateTime(r)):(moreDatetime||throws(SyntaxError$1("Local Time is not allowed before TOML v0.5"+where(", which at "))),asLocalTimes(e)[e.length]=new LocalTime(r)),t):r.indexOf("-")!==r.lastIndexOf("-")&&"-"!==r[0]?(moreDatetime||throws(SyntaxError$1("Local Date is not allowed before TOML v0.5"+where(", which at "))),asLocalDates(e)[e.length]=new LocalDate(r),t):("true"===r?asBooleans(e)[e.length]=!0:"false"===r?asBooleans(e)[e.length]=!1:r.includes(".")||(r.includes("e")||r.includes("E"))&&!r.startsWith("0x")?asFloats(e)[e.length]=Float(r):enableNull&&"null"===r?asNulls(e)[e.length]=null:asIntegers(e)[e.length]=Integer(r),t)},equalStaticArray=function*(e,t,r){const n=e[t]=newArray(!0),i=new mark("Static Array",r.length);r=r.replace(SYM_WHITESPACE,"");let a=!0;for(;!r||"#"===r[0];)a=!1,r=i.must().replace(PRE_WHITESPACE,"");if("]"===r[0])return a&&beInline(n,!0),r.replace(SYM_WHITESPACE,"");for(;;){const e=push(n,r);for(r="string"==typeof e?e:yield e;!r||"#"===r[0];)a=!1,r=i.must().replace(PRE_WHITESPACE,"");if(","===r[0]){for(r=r.replace(SYM_WHITESPACE,"");!r||"#"===r[0];)a=!1,r=i.must().replace(PRE_WHITESPACE,"");if("]"===r[0])break}else{if("]"===r[0])break;throws(SyntaxError$1("Unexpect character in static array item value"+where(", which is found at ")))}}return a&&beInline(n,!0),r.replace(SYM_WHITESPACE,"")},equalInlineTable=function*(e,t,r){const n=e[t]=new Table(!0,!0);if(allowInlineTableMultilineAndTrailingCommaEvenNoComma){const e=new mark("Inline Table",r.length);r=r.replace(SYM_WHITESPACE,"");let t=!0;for(;;){for(;!r||"#"===r[0];)t=!1,r=e.must().replace(PRE_WHITESPACE,"");if("}"===r[0])break;const i=ForComment(n,r),a=assign(i);if(r="string"==typeof a?a:yield a){if("#"===r[0]){preserveComment&&(i.table[commentFor(i.finalKey)]=r.slice(1)),t=!1;do{r=e.must().replace(PRE_WHITESPACE,"")}while(!r||"#"===r[0])}}else{t=!1;do{r=e.must().replace(PRE_WHITESPACE,"")}while(!r||"#"===r[0])}","===r[0]&&(r=r.replace(SYM_WHITESPACE,""))}t||beInline(n,!1)}else if("}"!==(r=r.replace(SYM_WHITESPACE,"")||throws(SyntaxError$1("Inline Table is intended to appear on a single line"+where(", which broken at "))))[0])for(;;){"#"===r[0]&&throws(SyntaxError$1("Inline Table is intended to appear on a single line"+where(", which broken at ")));const e=assign(ForComment(n,r));if("}"===(r=("string"==typeof e?e:yield e)||throws(SyntaxError$1("Inline Table is intended to appear on a single line"+where(", which broken at "))))[0])break;","===r[0]&&"}"===(r=r.replace(SYM_WHITESPACE,"")||throws(SyntaxError$1("Inline Table is intended to appear on a single line"+where(", which broken at "))))[0]&&throws(SyntaxError$1("The last property of an Inline Table can not have a trailing comma"+where(", which was found at ")))}return r.replace(SYM_WHITESPACE,"")},ForComment=(e,t)=>{const{leadingKeys:r,finalKey:n,tag:i}=({lineRest:t}=KEY_VALUE_PAIR_exec_groups(parseKeys(t)));return{table:prepareInlineTable(e,r),finalKey:n,tag:i,lineRest:t}},assign=({finalKey:e,tag:t,lineRest:r,table:n})=>{if(e in n&&throws(Error$1("Duplicate property definition"+where(" at "))),t)switch(collect(t,null,n,e),r&&r[0]){case",":case"}":case"":case"#":return n[e]=undefined$1,r}switch(r&&r[0]){case"'":return assignLiteralString(n,e,r);case'"':return assignBasicString(n,e,r);case"{":return inlineTable||throws(SyntaxError$1("Inline Table is not allowed before TOML v0.4"+where(", which at "))),equalInlineTable(n,e,r);case"[":return equalStaticArray(n,e,r)}const{1:i}=({2:r}=VALUE_REST_exec(r)??throws(SyntaxError$1("Bad atom value"+where(" at "))));if(sFloat){if("inf"===i||"+inf"===i)return n[e]=1/0,r;if("-inf"===i)return n[e]=-1/0,r;if("nan"===i||"+nan"===i||"-nan"===i)return n[e]=0/0,r}return i.includes(":")?(i.includes("-")?IS_OFFSET$(i)?n[e]=new OffsetDateTime(i):(moreDatetime||throws(SyntaxError$1("Local Date-Time is not allowed before TOML v0.5"+where(", which at "))),n[e]=new LocalDateTime(i)):(moreDatetime||throws(SyntaxError$1("Local Time is not allowed before TOML v0.5"+where(", which at "))),n[e]=new LocalTime(i)),r):i.indexOf("-")!==i.lastIndexOf("-")&&"-"!==i[0]?(moreDatetime||throws(SyntaxError$1("Local Date is not allowed before TOML v0.5"+where(", which at "))),n[e]=new LocalDate(i),r):(n[e]="true"===i||"false"!==i&&(i.includes(".")||(i.includes("e")||i.includes("E"))&&!i.startsWith("0x")?Float(i):enableNull&&"null"===i?null:Integer(i)),r)},Root=()=>{const e=new Table;let t=e;for(;lineIndex!==lastLineIndex;){const r=sourceLines[++lineIndex].replace(PRE_WHITESPACE,"");if(r)if("["===r[0]){const{leadingKeys:n,finalKey:i,asArrayItem:a,tag:s,lineRest:l}=TABLE_DEFINITION_exec_groups(r,parseKeys),o=prepareTable(e,n);l&&("#"===l[0]?preserveComment&&!a&&(o[commentFor(i)]=l.slice(1)):throws(SyntaxError$1("Unexpect charachtor after table header"+where(" at ")))),t=appendTable(o,i,a,s)}else if("#"===r[0])__CONTROL_CHARACTER_EXCLUDE_test(r)&&throws(SyntaxError$1("Control characters other than Tab are not permitted in comments"+where(", which was found at ")));else{const e=ForComment(t,r);let n=assign(e);"string"==typeof n||(n=x(n)),n&&("#"===n[0]?preserveComment&&(e.table[commentFor(e.finalKey)]=n.slice(1)):throws(SyntaxError$1("Unexpect charachtor after key/value pair"+where(" at "))))}}return e},Uint8Array$1=Uint8Array,Buffer$1="undefined"==typeof Buffer?undefined$1:Buffer,isArrayBufferLike=e=>"byteLength"in e,message="A TOML doc must be a (ful-scalar) valid UTF-8 file, without any unknown code point.",arrayBufferLike2string=Buffer$1?(({isBuffer:e,[Symbol.species]:t,byteLength:r,allocUnsafe:n})=>i=>{if(!i.byteLength)return"";const a=e(i)?i:"length"in i?new t(i.buffer,i.byteOffset,i.length):new t(i),s=a.toString(),l=r(s);if(l===a.length){const e=n(l);if(e.utf8Write(s,0,l),e.equals(a))return"\ufeff"===s[0]?s.slice(1):s}throw Error$1(message)})(Buffer$1):e=>{if(!e.byteLength)return"";const t="length"in e?e:new Uint8Array$1(e),{length:r}=t,n=r-1,i=n-1,a=i-1,s=[];let l=0,o=0;do{let e=t[o];if(e<192){if(e<128){s[l++]=fromCharCode(e),o+=1;continue}}else if(e<224){if(o<n){const r=t[o+1];if(128==(192&r)&&(e=(31&e)<<6|63&r,127<e)){s[l++]=fromCharCode(e),o+=2;continue}}}else if(e<240){if(o<i){const r=t[o+1],n=t[o+2];if(128==(192&r)&&128==(192&n)&&(e=(15&e)<<12|(63&r)<<6|63&n,(e<55296?2047:57343)<e)){s[l++]=fromCharCode(e),o+=3;continue}}}else if(o<a){const r=t[o+1],n=t[o+2],i=t[o+3];if(128==(192&r)&&128==(192&n)&&128==(192&i)&&(e=(15&e)<<18|(63&r)<<12|(63&n)<<6|63&i,65535<e&&e<1114112)){s[l++]=fromCodePoint(e),o+=4;continue}}throw Error$1(message)}while(o!==r);const c=s.join("");return"\ufeff"===c[0]?c.slice(1):c},IS_NON_SCALAR=(()=>theRegExp(/[\uD800-\uDFFF]/u).test)();let holding=!1;const parse=(e,t,r,n,i)=>{if(holding)throw Error$1("parse during parsing.");let a,s;holding=!0;try{let l="";if("object"==typeof e&&e)if(isArrayBufferLike(e))e=arrayBufferLike2string(e);else{if(l=e.path,"string"!=typeof l)throw TypeError$1("TOML.parse(source.path)");const{data:t,require:r=("function"==typeof require?require:undefined$1)}=e;if(r){const n=r.resolve?.paths?.("")?.[0]?.replace(/node_modules$/,"");if(n&&(l=r("path").resolve(n,l),"string"!=typeof l))throw TypeError$1("TOML.parse(source.require('path').resolve)");if(t===undefined$1){const t=r("fs").readFileSync(l);if("object"!=typeof t||!t||!isArrayBufferLike(t))throw TypeError$1("TOML.parse(source.require('fs').readFileSync)");e=arrayBufferLike2string(t)}else if("string"==typeof t)e=t;else{if("object"!=typeof t||!t||!isArrayBufferLike(t))throw TypeError$1("TOML.parse(source.data)");e=arrayBufferLike2string(t)}}else{if(t===undefined$1)throw TypeError$1("TOML.parse(source.data|source.require)");if("string"==typeof t)e=t;else{if("object"!=typeof t||!t||!isArrayBufferLike(t))throw TypeError$1("TOML.parse(source.data)");e=arrayBufferLike2string(t)}}}else if("string"!=typeof e)throw TypeError$1("TOML.parse(source)");try{if(IS_NON_SCALAR(e))throw Error$1("A TOML doc must be a (ful-scalar) valid UTF-8 file, without any uncoupled UCS-4 character code.");if("object"==typeof r&&r){if(n!==undefined$1||i!==undefined$1)throw TypeError$1("options mode ? args mode");({multilineStringJoiner:r,useBigInt:n,x:i}=r)}try{use(t,r,n,i),todo(e,l);try{a=Root(),s=Process()}finally{done()}}finally{processor=null,collection.length=collection_length=0,zeroDatetime=!1,useWhatToJoinMultilineString=null}}finally{clearRegExp()}}finally{holding=!1}return s?.(),a},parse$1=assign$1(((e,t,r,n,i)=>"number"==typeof t?parse(e,t,r,n,i):parse(e,1,t,r,n)),{"1.0":(e,t,r,n)=>parse(e,.1,t,r,n),1:(e,t,r,n)=>parse(e,1,t,r,n),.5:(e,t,r,n)=>parse(e,.5,t,r,n),.4:(e,t,r,n)=>parse(e,.4,t,r,n),.3:(e,t,r,n)=>parse(e,.3,t,r,n),.2:(e,t,r,n)=>parse(e,.2,t,r,n),.1:(e,t,r,n)=>parse(e,.1,t,r,n)}),getOwnPropertyNames=Object.getOwnPropertyNames,Boolean$1=Boolean,String$1=String,Number$1=Number,LITERAL=new WeakSet$1,isLiteral=set_has.bind(LITERAL),beLiteral=set_add.bind(LITERAL),literal=(e,...t)=>{if("string"!=typeof e){let r=t.length;if(r){const{raw:n}=e;for(e=n[r];r;)t[--r]+=n[r];e=t.join("")+e}else e=e.raw[0]}const r=e.split("\n");return beLiteral(r),r},ESCAPED=Null$1({...fromEntries([...Array$1(32)].map(((e,t)=>[fromCharCode(t),"\\u"+t.toString(16).toUpperCase().padStart(4,"0")]))),"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"','"""':'""\\"',"\\":"\\\\","":"\\u007F"}),NEED_BASIC=(()=>theRegExp(/[\x00-\x08\x0A-\x1F'\x7F]/).test)(),BY_ESCAPE=/[^\x00-\x08\x0A-\x1F"\\\x7F]+|./gs,NEED_ESCAPE=(()=>theRegExp(/^[\x00-\x08\x0A-\x1F"\\\x7F]/).test)(),literalString=e=>`'${e}'`,singlelineString=e=>{if(NEED_BASIC(e)){const t=e.match(BY_ESCAPE);let r=t.length;do{NEED_ESCAPE(t[--r])&&(t[r]=ESCAPED[t[r]])}while(r);return`"${t.join("")}"`}return`'${e}'`},NEED_MULTILINE_BASIC=(()=>theRegExp(/[\x00-\x08\x0A-\x1F\x7F]|'''/).test)(),REAL_MULTILINE_ESCAPE=(()=>theRegExp(/[\x00-\x08\x0A-\x1F\\\x7F]|"""/).test)(),BY_MULTILINE_ESCAPE=/[^\x00-\x08\x0A-\x1F"\\\x7F]+|"""|./gs,NEED_MULTILINE_ESCAPE=(()=>theRegExp(/^(?:[\x00-\x08\x0A-\x1F\\\x7F]|""")/).test)(),escape_multiline=(e,t)=>{const r=e[t];if(REAL_MULTILINE_ESCAPE(r)){const n=r.match(BY_MULTILINE_ESCAPE);let i=n.length;do{NEED_MULTILINE_ESCAPE(n[--i])&&(n[i]=ESCAPED[n[i]])}while(i);e[t]=n.join("")}},Lines=e=>(1===(e=["",...e]).length&&(e[1]=""),e),multilineString=e=>{const t=e.length-1;let r=t;do{if(NEED_MULTILINE_BASIC(e[r]))break}while(--r);if(r)for(r=t,escape_multiline(e,r),e[r]+=e[0]='"""';--r;)escape_multiline(e,r);else e[t]+=e[0]="'''";return beLiteral(e),e},multilineBasicString=e=>{let t=e.length-1;for(escape_multiline(e,t),e[t]+=e[0]='"""';--t;)escape_multiline(e,t);return beLiteral(e),e},_Infinity=-1/0,INTEGER_LIKE=(()=>theRegExp(/^-?\d+$/).test)(),ensureFloat=e=>INTEGER_LIKE(e)?e+".0":e,float=e=>e?1/0===e?"inf":e===-1/0?"-inf":ensureFloat(""+e):e==e?is(e,0)?"0.0":"-0.0":"nan",BARE=(()=>theRegExp(/^[\w-]+$/).test)(),$Key$=e=>BARE(e)?e:singlelineString(e),FIRST=/[^.]+/,$Keys=e=>IS_INTEGER(e)||IS_FLOAT_OR_XXXX(e)?e.replace(FIRST,literalString):e;class TOMLSection extends Array$1{document;constructor(e){return super(),this.document=e,this}[Symbol.toPrimitive](){return this.join(this.document.newline)}appendNewline(){this[this.length]=""}set appendLine(e){this[this.length]=e}set appendInline(e){this[this.length-1]+=e}set appendInlineIf(e){e&&(this[this.length-1]+=e)}*assignBlock(e,t,r,n){const{document:i}=this,{newlineUnderHeader:a,newlineUnderSectionButPair:s}=i,l=!!t&&i.newlineUnderPairButDotted,o=t?i.newlineUnderDotted:i.newlineUnderPair;for(const c of n){const n=r[c],_=$Key$(c),u=e+_;if(isArray$1(n)){if(n.length&&isSection(n[0])){const e=`[[${u}]]`,t=u+".";for(const r of n){const n=i.appendSection();n[0]=e,a?(n[1]="",yield n.assignBlock(t,"",r,getOwnPropertyNames(r)),s&&2!==n.length&&n.appendNewline()):(yield n.assignBlock(t,"",r,getOwnPropertyNames(r)),s&&n.appendNewline())}continue}}else if(isSection(n)){const e=i.appendSection();e[0]=`[${u}]${getComment(r,c)}`,a?(e[1]="",yield e.assignBlock(u+".","",n,getOwnPropertyNames(n)),s&&2!==e.length&&e.appendNewline()):(yield e.assignBlock(u+".","",n,getOwnPropertyNames(n)),s&&e.appendNewline());continue}const E=t+_;this.appendLine=$Keys(E)+" = ";const T=this.value("",n,getOwnPropertyNames);T?(--this.length,yield this.assignBlock(u+".",E+".",n,T),l&&this.appendNewline()):(this.appendInlineIf=getComment(r,c),o&&this.appendNewline())}}value(e,t,r){switch(typeof t){case"object":if(null===t){if(this.document.nullDisabled)throw TypeError$1('toml can not stringify "null" type value without truthy options.xNull');this.appendInline="null";break}if(isLiteral(t)){const{length:e}=t;this.appendInline=t[0];let r=1;for(;r!==e;)this.appendLine=t[r++];break}const n=ofInline(t);if(isArray$1(t)){n?this.singlelineArray(e,t):this.staticArray(e,t);break}if(n!==undefined$1){n||this.document.multilineTableDisabled?this.inlineTable(e,t):this.multilineTable(e,t,this.document.multilineTableComma);break}if(t instanceof TOMLDatetime){this.appendInline=this.document._?t.toISOString().replace("T"," "):t.toISOString();break}if(t instanceof String$1)throw TypeError$1("TOML.stringify refuse to handle [object String]");if(r){const e=r(t);if(e.length)return e;this.appendInline="{ }";break}if(t instanceof BigInt$1)throw TypeError$1("TOML.stringify refuse to handle [object BigInt]");if(t instanceof Number$1)throw TypeError$1("TOML.stringify refuse to handle [object Number]");if(t instanceof Boolean$1)throw TypeError$1("TOML.stringify refuse to handle [object Boolean]");if(t instanceof Symbol_)throw TypeError$1("TOML.stringify refuse to handle [object Symbol]");this.inlineTable(e,t);break;case"bigint":this.appendInline=""+t;break;case"number":this.appendInline=float(t);break;case"string":this.appendInline=singlelineString(t);break;case"boolean":this.appendInline=t?"true":"false";break;default:throw TypeError$1(`toml can not stringify "${typeof t}" type value`)}return null}singlelineArray(e,t){const{length:r}=t;if(r){this.appendInline="[ ",this.value(e,t[0]);let n=1;for(;n!==r;)this.appendInline=", ",this.value(e,t[n++]);this.appendInline=" ]"}else this.appendInline="[ ]"}staticArray(e,t){this.appendInline="[";const r=e+this.document.indent;for(const n of t)this.appendLine=r,this.value(r,n),this.appendInline=",";this.appendLine=e+"]"}inlineTable(e,t){const r=getOwnPropertyNames(t);r.length?(this.appendInline="{ ",this.assignInline(e,t,"",r),this[this.length-1]=this[this.length-1].slice(0,-2)+" }"):this.appendInline="{ }"}multilineTable(e,t,r){this.appendInline="{",this.assignMultiline(e,t,"",getOwnPropertyNames(t),r),this.appendLine=e+"}"}assignInline(e,t,r,n){for(const i of n){const n=t[i],a=r+$Key$(i),s=this.appendInline=$Keys(a)+" = ",l=this.value(e,n,getOwnPropertyNames);l?(this[this.length-1]=this[this.length-1].slice(0,-s.length),this.assignInline(e,n,a+".",l)):this.appendInline=", "}}assignMultiline(e,t,r,n,i){const a=e+this.document.indent;for(const s of n){const n=t[s],l=r+$Key$(s);this.appendLine=a+$Keys(l)+" = ";const o=this.value(a,n,getOwnPropertyNames);o?(--this.length,this.assignMultiline(e,n,l+".",o,i)):i?this.appendInline=","+getComment(t,s):this.appendInlineIf=getComment(t,s)}}}const name2code=Null$1({document:0,section:1,header:2,pairs:3,pair:4}),IS_INDENT=(()=>theRegExp(/^[\t ]*$/).test)();class TOMLDocument extends Array$1{get["constructor"](){return Array$1}0=new TOMLSection(this);newline;newlineUnderSection;newlineUnderSectionButPair;newlineUnderHeader;newlineUnderPair;newlineUnderPairButDotted;newlineUnderDotted;indent;_;nullDisabled;multilineTableDisabled;multilineTableComma;constructor(e){super();const t=e?.newline;if(void 0!==t&&"\n"!==t&&"\r\n"!==t)throw"string"==typeof t?SyntaxError$1("TOML.stringify(,{newline}) can only be valid TOML newline"):TypeError$1("TOML.stringify(,{newline}) can only be string");this.newline=t??"";const r=name2code[e?.newlineAround??"header"]??name2code.header;this.newlineUnderSection=r>0,this.newlineUnderSectionButPair=1===r||2===r,this.newlineUnderHeader=r>1,this.newlineUnderPair=r>2,this.newlineUnderPairButDotted=3===r,this.newlineUnderDotted=r>3;const n=e?.indent;if(void 0===n)this.indent="\t";else if("string"==typeof n){if(!IS_INDENT(n))throw SyntaxError$1("TOML.stringify(,{indent}) can only include Tab or Space");this.indent=n}else{if("number"!=typeof n)throw TypeError$1(`TOML.stringify(,{indent}) can not be "${typeof n}" type`);if(!isSafeInteger(n))throw RangeError$1(`TOML.stringify(,{indent:${n}}) is out of range`);this.indent=" ".repeat(n)}this._=" "===e?.T,this.nullDisabled=!e?.xNull;const i=e?.xBeforeNewlineInMultilineTable;return""===i?(this.multilineTableDisabled=!1,this.multilineTableComma=!1):","===i?(this.multilineTableDisabled=!1,this.multilineTableComma=!0):(this.multilineTableDisabled=!0,this.multilineTableComma=!0),this}appendSection(){return this[this.length]=new TOMLSection(this)}}const stringify=(e,t)=>{const r=new TOMLDocument(t),n=r[0];return n[0]="",x(n.assignBlock("","",e,getOwnPropertyNames(e))),r.newlineUnderSectionButPair&&1!==n.length&&n.appendNewline(),r.newlineUnderSection||r[r.length-1].appendNewline(),r.newline?r.join(r.newline):r.flat()},multiline=(()=>{const e=e=>"string"==typeof e?multilineString(("\n"+e).split("\n")):isArray$1(e)?multilineString(Lines(e)):multilineTable(e);return e.basic=e=>multilineBasicString("string"==typeof e?("\n"+e).split("\n"):Lines(e)),freeze(e),e})(),_export=Default({version,parse:parse$1,stringify,Section,inline,multiline,literal,commentFor,OffsetDateTime,LocalDateTime,LocalDate,LocalTime});export default _export;export{LocalDate,LocalDateTime,LocalTime,OffsetDateTime,Section,commentFor,inline,literal,multiline,parse$1 as parse,stringify,version};
//# sourceMappingURL=j-toml.min.js.map